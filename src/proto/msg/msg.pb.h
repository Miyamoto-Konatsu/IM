// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_msg_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_msg_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_msg_2eproto;
namespace ServerRpc {
namespace msg {
class getHasReadSeqAndMaxSeqReq;
struct getHasReadSeqAndMaxSeqReqDefaultTypeInternal;
extern getHasReadSeqAndMaxSeqReqDefaultTypeInternal _getHasReadSeqAndMaxSeqReq_default_instance_;
class getHasReadSeqAndMaxSeqResp;
struct getHasReadSeqAndMaxSeqRespDefaultTypeInternal;
extern getHasReadSeqAndMaxSeqRespDefaultTypeInternal _getHasReadSeqAndMaxSeqResp_default_instance_;
class msg;
struct msgDefaultTypeInternal;
extern msgDefaultTypeInternal _msg_default_instance_;
class pullMsgs;
struct pullMsgsDefaultTypeInternal;
extern pullMsgsDefaultTypeInternal _pullMsgs_default_instance_;
class sendMsgReq;
struct sendMsgReqDefaultTypeInternal;
extern sendMsgReqDefaultTypeInternal _sendMsgReq_default_instance_;
class sendMsgResp;
struct sendMsgRespDefaultTypeInternal;
extern sendMsgRespDefaultTypeInternal _sendMsgResp_default_instance_;
class setHasReadSeqReq;
struct setHasReadSeqReqDefaultTypeInternal;
extern setHasReadSeqReqDefaultTypeInternal _setHasReadSeqReq_default_instance_;
class setHasReadSeqResp;
struct setHasReadSeqRespDefaultTypeInternal;
extern setHasReadSeqRespDefaultTypeInternal _setHasReadSeqResp_default_instance_;
class syncMsgsReq;
struct syncMsgsReqDefaultTypeInternal;
extern syncMsgsReqDefaultTypeInternal _syncMsgsReq_default_instance_;
class syncMsgsResp;
struct syncMsgsRespDefaultTypeInternal;
extern syncMsgsRespDefaultTypeInternal _syncMsgsResp_default_instance_;
}  // namespace msg
}  // namespace ServerRpc
PROTOBUF_NAMESPACE_OPEN
template <>
::ServerRpc::msg::getHasReadSeqAndMaxSeqReq* Arena::CreateMaybeMessage<::ServerRpc::msg::getHasReadSeqAndMaxSeqReq>(Arena*);
template <>
::ServerRpc::msg::getHasReadSeqAndMaxSeqResp* Arena::CreateMaybeMessage<::ServerRpc::msg::getHasReadSeqAndMaxSeqResp>(Arena*);
template <>
::ServerRpc::msg::msg* Arena::CreateMaybeMessage<::ServerRpc::msg::msg>(Arena*);
template <>
::ServerRpc::msg::pullMsgs* Arena::CreateMaybeMessage<::ServerRpc::msg::pullMsgs>(Arena*);
template <>
::ServerRpc::msg::sendMsgReq* Arena::CreateMaybeMessage<::ServerRpc::msg::sendMsgReq>(Arena*);
template <>
::ServerRpc::msg::sendMsgResp* Arena::CreateMaybeMessage<::ServerRpc::msg::sendMsgResp>(Arena*);
template <>
::ServerRpc::msg::setHasReadSeqReq* Arena::CreateMaybeMessage<::ServerRpc::msg::setHasReadSeqReq>(Arena*);
template <>
::ServerRpc::msg::setHasReadSeqResp* Arena::CreateMaybeMessage<::ServerRpc::msg::setHasReadSeqResp>(Arena*);
template <>
::ServerRpc::msg::syncMsgsReq* Arena::CreateMaybeMessage<::ServerRpc::msg::syncMsgsReq>(Arena*);
template <>
::ServerRpc::msg::syncMsgsResp* Arena::CreateMaybeMessage<::ServerRpc::msg::syncMsgsResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace ServerRpc {
namespace msg {

// ===================================================================


// -------------------------------------------------------------------

class msg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.msg) */ {
 public:
  inline msg() : msg(nullptr) {}
  ~msg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR msg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  msg(const msg& from);
  msg(msg&& from) noexcept
    : msg() {
    *this = ::std::move(from);
  }

  inline msg& operator=(const msg& from) {
    CopyFrom(from);
    return *this;
  }
  inline msg& operator=(msg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const msg& default_instance() {
    return *internal_default_instance();
  }
  static inline const msg* internal_default_instance() {
    return reinterpret_cast<const msg*>(
               &_msg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(msg& a, msg& b) {
    a.Swap(&b);
  }
  inline void Swap(msg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(msg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  msg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<msg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const msg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const msg& from) {
    msg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(msg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.msg";
  }
  protected:
  explicit msg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromUserIDFieldNumber = 1,
    kToUserIDFieldNumber = 2,
    kContentFieldNumber = 3,
    kGroupIDFieldNumber = 8,
    kCreateTimeFieldNumber = 4,
    kSeqFieldNumber = 5,
    kPlatformIDFieldNumber = 6,
    kMsgTypeFieldNumber = 7,
  };
  // string fromUserID = 1;
  void clear_fromuserid() ;
  const std::string& fromuserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fromuserid(Arg_&& arg, Args_... args);
  std::string* mutable_fromuserid();
  PROTOBUF_NODISCARD std::string* release_fromuserid();
  void set_allocated_fromuserid(std::string* ptr);

  private:
  const std::string& _internal_fromuserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromuserid(
      const std::string& value);
  std::string* _internal_mutable_fromuserid();

  public:
  // string toUserID = 2;
  void clear_touserid() ;
  const std::string& touserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_touserid(Arg_&& arg, Args_... args);
  std::string* mutable_touserid();
  PROTOBUF_NODISCARD std::string* release_touserid();
  void set_allocated_touserid(std::string* ptr);

  private:
  const std::string& _internal_touserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_touserid(
      const std::string& value);
  std::string* _internal_mutable_touserid();

  public:
  // string content = 3;
  void clear_content() ;
  const std::string& content() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* ptr);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // string groupID = 8;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // int64 createTime = 4;
  void clear_createtime() ;
  ::int64_t createtime() const;
  void set_createtime(::int64_t value);

  private:
  ::int64_t _internal_createtime() const;
  void _internal_set_createtime(::int64_t value);

  public:
  // int64 seq = 5;
  void clear_seq() ;
  ::int64_t seq() const;
  void set_seq(::int64_t value);

  private:
  ::int64_t _internal_seq() const;
  void _internal_set_seq(::int64_t value);

  public:
  // int32 platformID = 6;
  void clear_platformid() ;
  ::int32_t platformid() const;
  void set_platformid(::int32_t value);

  private:
  ::int32_t _internal_platformid() const;
  void _internal_set_platformid(::int32_t value);

  public:
  // int32 msgType = 7;
  void clear_msgtype() ;
  ::int32_t msgtype() const;
  void set_msgtype(::int32_t value);

  private:
  ::int32_t _internal_msgtype() const;
  void _internal_set_msgtype(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.msg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromuserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr touserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::int64_t createtime_;
    ::int64_t seq_;
    ::int32_t platformid_;
    ::int32_t msgtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class sendMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.sendMsgReq) */ {
 public:
  inline sendMsgReq() : sendMsgReq(nullptr) {}
  ~sendMsgReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR sendMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  sendMsgReq(const sendMsgReq& from);
  sendMsgReq(sendMsgReq&& from) noexcept
    : sendMsgReq() {
    *this = ::std::move(from);
  }

  inline sendMsgReq& operator=(const sendMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline sendMsgReq& operator=(sendMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const sendMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const sendMsgReq* internal_default_instance() {
    return reinterpret_cast<const sendMsgReq*>(
               &_sendMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(sendMsgReq& a, sendMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(sendMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sendMsgReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  sendMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<sendMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const sendMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const sendMsgReq& from) {
    sendMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sendMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.sendMsgReq";
  }
  protected:
  explicit sendMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 1,
  };
  // .ServerRpc.msg.msg msg_data = 1;
  bool has_msg_data() const;
  void clear_msg_data() ;
  const ::ServerRpc::msg::msg& msg_data() const;
  PROTOBUF_NODISCARD ::ServerRpc::msg::msg* release_msg_data();
  ::ServerRpc::msg::msg* mutable_msg_data();
  void set_allocated_msg_data(::ServerRpc::msg::msg* msg_data);
  private:
  const ::ServerRpc::msg::msg& _internal_msg_data() const;
  ::ServerRpc::msg::msg* _internal_mutable_msg_data();
  public:
  void unsafe_arena_set_allocated_msg_data(
      ::ServerRpc::msg::msg* msg_data);
  ::ServerRpc::msg::msg* unsafe_arena_release_msg_data();
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.sendMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ServerRpc::msg::msg* msg_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class sendMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.sendMsgResp) */ {
 public:
  inline sendMsgResp() : sendMsgResp(nullptr) {}
  ~sendMsgResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR sendMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  sendMsgResp(const sendMsgResp& from);
  sendMsgResp(sendMsgResp&& from) noexcept
    : sendMsgResp() {
    *this = ::std::move(from);
  }

  inline sendMsgResp& operator=(const sendMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline sendMsgResp& operator=(sendMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const sendMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const sendMsgResp* internal_default_instance() {
    return reinterpret_cast<const sendMsgResp*>(
               &_sendMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(sendMsgResp& a, sendMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(sendMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sendMsgResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  sendMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<sendMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const sendMsgResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const sendMsgResp& from) {
    sendMsgResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sendMsgResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.sendMsgResp";
  }
  protected:
  explicit sendMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendTimeFieldNumber = 1,
  };
  // int64 sendTime = 1;
  void clear_sendtime() ;
  ::int64_t sendtime() const;
  void set_sendtime(::int64_t value);

  private:
  ::int64_t _internal_sendtime() const;
  void _internal_set_sendtime(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.sendMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t sendtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class pullMsgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.pullMsgs) */ {
 public:
  inline pullMsgs() : pullMsgs(nullptr) {}
  ~pullMsgs() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR pullMsgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  pullMsgs(const pullMsgs& from);
  pullMsgs(pullMsgs&& from) noexcept
    : pullMsgs() {
    *this = ::std::move(from);
  }

  inline pullMsgs& operator=(const pullMsgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline pullMsgs& operator=(pullMsgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const pullMsgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const pullMsgs* internal_default_instance() {
    return reinterpret_cast<const pullMsgs*>(
               &_pullMsgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(pullMsgs& a, pullMsgs& b) {
    a.Swap(&b);
  }
  inline void Swap(pullMsgs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(pullMsgs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  pullMsgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<pullMsgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const pullMsgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const pullMsgs& from) {
    pullMsgs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pullMsgs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.pullMsgs";
  }
  protected:
  explicit pullMsgs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgsFieldNumber = 1,
  };
  // repeated .ServerRpc.msg.msg msgs = 1;
  int msgs_size() const;
  private:
  int _internal_msgs_size() const;

  public:
  void clear_msgs() ;
  ::ServerRpc::msg::msg* mutable_msgs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::msg::msg >*
      mutable_msgs();
  private:
  const ::ServerRpc::msg::msg& _internal_msgs(int index) const;
  ::ServerRpc::msg::msg* _internal_add_msgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::msg::msg>& _internal_msgs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::msg::msg>* _internal_mutable_msgs();
  public:
  const ::ServerRpc::msg::msg& msgs(int index) const;
  ::ServerRpc::msg::msg* add_msgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::msg::msg >&
      msgs() const;
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.pullMsgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::msg::msg > msgs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class setHasReadSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.setHasReadSeqReq) */ {
 public:
  inline setHasReadSeqReq() : setHasReadSeqReq(nullptr) {}
  ~setHasReadSeqReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR setHasReadSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  setHasReadSeqReq(const setHasReadSeqReq& from);
  setHasReadSeqReq(setHasReadSeqReq&& from) noexcept
    : setHasReadSeqReq() {
    *this = ::std::move(from);
  }

  inline setHasReadSeqReq& operator=(const setHasReadSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline setHasReadSeqReq& operator=(setHasReadSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setHasReadSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const setHasReadSeqReq* internal_default_instance() {
    return reinterpret_cast<const setHasReadSeqReq*>(
               &_setHasReadSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(setHasReadSeqReq& a, setHasReadSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(setHasReadSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setHasReadSeqReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setHasReadSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setHasReadSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const setHasReadSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const setHasReadSeqReq& from) {
    setHasReadSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(setHasReadSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.setHasReadSeqReq";
  }
  protected:
  explicit setHasReadSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromUserIDFieldNumber = 1,
    kToUserIDFieldNumber = 2,
    kGroupIDFieldNumber = 3,
    kSeqFieldNumber = 5,
    kMsgTypeFieldNumber = 4,
  };
  // string fromUserID = 1;
  void clear_fromuserid() ;
  const std::string& fromuserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fromuserid(Arg_&& arg, Args_... args);
  std::string* mutable_fromuserid();
  PROTOBUF_NODISCARD std::string* release_fromuserid();
  void set_allocated_fromuserid(std::string* ptr);

  private:
  const std::string& _internal_fromuserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromuserid(
      const std::string& value);
  std::string* _internal_mutable_fromuserid();

  public:
  // string toUserID = 2;
  void clear_touserid() ;
  const std::string& touserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_touserid(Arg_&& arg, Args_... args);
  std::string* mutable_touserid();
  PROTOBUF_NODISCARD std::string* release_touserid();
  void set_allocated_touserid(std::string* ptr);

  private:
  const std::string& _internal_touserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_touserid(
      const std::string& value);
  std::string* _internal_mutable_touserid();

  public:
  // string groupID = 3;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // int64 seq = 5;
  void clear_seq() ;
  ::int64_t seq() const;
  void set_seq(::int64_t value);

  private:
  ::int64_t _internal_seq() const;
  void _internal_set_seq(::int64_t value);

  public:
  // int32 msgType = 4;
  void clear_msgtype() ;
  ::int32_t msgtype() const;
  void set_msgtype(::int32_t value);

  private:
  ::int32_t _internal_msgtype() const;
  void _internal_set_msgtype(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.setHasReadSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromuserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr touserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::int64_t seq_;
    ::int32_t msgtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class setHasReadSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.setHasReadSeqResp) */ {
 public:
  inline setHasReadSeqResp() : setHasReadSeqResp(nullptr) {}
  ~setHasReadSeqResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR setHasReadSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  setHasReadSeqResp(const setHasReadSeqResp& from);
  setHasReadSeqResp(setHasReadSeqResp&& from) noexcept
    : setHasReadSeqResp() {
    *this = ::std::move(from);
  }

  inline setHasReadSeqResp& operator=(const setHasReadSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline setHasReadSeqResp& operator=(setHasReadSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setHasReadSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const setHasReadSeqResp* internal_default_instance() {
    return reinterpret_cast<const setHasReadSeqResp*>(
               &_setHasReadSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(setHasReadSeqResp& a, setHasReadSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(setHasReadSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setHasReadSeqResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setHasReadSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setHasReadSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const setHasReadSeqResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const setHasReadSeqResp& from) {
    setHasReadSeqResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(setHasReadSeqResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.setHasReadSeqResp";
  }
  protected:
  explicit setHasReadSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendTimeFieldNumber = 1,
  };
  // int64 sendTime = 1;
  void clear_sendtime() ;
  ::int64_t sendtime() const;
  void set_sendtime(::int64_t value);

  private:
  ::int64_t _internal_sendtime() const;
  void _internal_set_sendtime(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.setHasReadSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t sendtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class getHasReadSeqAndMaxSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.getHasReadSeqAndMaxSeqReq) */ {
 public:
  inline getHasReadSeqAndMaxSeqReq() : getHasReadSeqAndMaxSeqReq(nullptr) {}
  ~getHasReadSeqAndMaxSeqReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getHasReadSeqAndMaxSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getHasReadSeqAndMaxSeqReq(const getHasReadSeqAndMaxSeqReq& from);
  getHasReadSeqAndMaxSeqReq(getHasReadSeqAndMaxSeqReq&& from) noexcept
    : getHasReadSeqAndMaxSeqReq() {
    *this = ::std::move(from);
  }

  inline getHasReadSeqAndMaxSeqReq& operator=(const getHasReadSeqAndMaxSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getHasReadSeqAndMaxSeqReq& operator=(getHasReadSeqAndMaxSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getHasReadSeqAndMaxSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getHasReadSeqAndMaxSeqReq* internal_default_instance() {
    return reinterpret_cast<const getHasReadSeqAndMaxSeqReq*>(
               &_getHasReadSeqAndMaxSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(getHasReadSeqAndMaxSeqReq& a, getHasReadSeqAndMaxSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getHasReadSeqAndMaxSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getHasReadSeqAndMaxSeqReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getHasReadSeqAndMaxSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getHasReadSeqAndMaxSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getHasReadSeqAndMaxSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getHasReadSeqAndMaxSeqReq& from) {
    getHasReadSeqAndMaxSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getHasReadSeqAndMaxSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.getHasReadSeqAndMaxSeqReq";
  }
  protected:
  explicit getHasReadSeqAndMaxSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromUserIDFieldNumber = 1,
    kToUserIDFieldNumber = 2,
    kGroupIDFieldNumber = 3,
    kMsgTypeFieldNumber = 4,
  };
  // string fromUserID = 1;
  void clear_fromuserid() ;
  const std::string& fromuserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fromuserid(Arg_&& arg, Args_... args);
  std::string* mutable_fromuserid();
  PROTOBUF_NODISCARD std::string* release_fromuserid();
  void set_allocated_fromuserid(std::string* ptr);

  private:
  const std::string& _internal_fromuserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromuserid(
      const std::string& value);
  std::string* _internal_mutable_fromuserid();

  public:
  // string toUserID = 2;
  void clear_touserid() ;
  const std::string& touserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_touserid(Arg_&& arg, Args_... args);
  std::string* mutable_touserid();
  PROTOBUF_NODISCARD std::string* release_touserid();
  void set_allocated_touserid(std::string* ptr);

  private:
  const std::string& _internal_touserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_touserid(
      const std::string& value);
  std::string* _internal_mutable_touserid();

  public:
  // string groupID = 3;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // int32 msgType = 4;
  void clear_msgtype() ;
  ::int32_t msgtype() const;
  void set_msgtype(::int32_t value);

  private:
  ::int32_t _internal_msgtype() const;
  void _internal_set_msgtype(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.getHasReadSeqAndMaxSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromuserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr touserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::int32_t msgtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class getHasReadSeqAndMaxSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.getHasReadSeqAndMaxSeqResp) */ {
 public:
  inline getHasReadSeqAndMaxSeqResp() : getHasReadSeqAndMaxSeqResp(nullptr) {}
  ~getHasReadSeqAndMaxSeqResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getHasReadSeqAndMaxSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getHasReadSeqAndMaxSeqResp(const getHasReadSeqAndMaxSeqResp& from);
  getHasReadSeqAndMaxSeqResp(getHasReadSeqAndMaxSeqResp&& from) noexcept
    : getHasReadSeqAndMaxSeqResp() {
    *this = ::std::move(from);
  }

  inline getHasReadSeqAndMaxSeqResp& operator=(const getHasReadSeqAndMaxSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getHasReadSeqAndMaxSeqResp& operator=(getHasReadSeqAndMaxSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getHasReadSeqAndMaxSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getHasReadSeqAndMaxSeqResp* internal_default_instance() {
    return reinterpret_cast<const getHasReadSeqAndMaxSeqResp*>(
               &_getHasReadSeqAndMaxSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(getHasReadSeqAndMaxSeqResp& a, getHasReadSeqAndMaxSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getHasReadSeqAndMaxSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getHasReadSeqAndMaxSeqResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getHasReadSeqAndMaxSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getHasReadSeqAndMaxSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getHasReadSeqAndMaxSeqResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getHasReadSeqAndMaxSeqResp& from) {
    getHasReadSeqAndMaxSeqResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getHasReadSeqAndMaxSeqResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.getHasReadSeqAndMaxSeqResp";
  }
  protected:
  explicit getHasReadSeqAndMaxSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasReadSeqFieldNumber = 1,
    kMaxSeqFieldNumber = 2,
  };
  // int64 hasReadSeq = 1;
  void clear_hasreadseq() ;
  ::int64_t hasreadseq() const;
  void set_hasreadseq(::int64_t value);

  private:
  ::int64_t _internal_hasreadseq() const;
  void _internal_set_hasreadseq(::int64_t value);

  public:
  // int64 maxSeq = 2;
  void clear_maxseq() ;
  ::int64_t maxseq() const;
  void set_maxseq(::int64_t value);

  private:
  ::int64_t _internal_maxseq() const;
  void _internal_set_maxseq(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.getHasReadSeqAndMaxSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t hasreadseq_;
    ::int64_t maxseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class syncMsgsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.syncMsgsReq) */ {
 public:
  inline syncMsgsReq() : syncMsgsReq(nullptr) {}
  ~syncMsgsReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR syncMsgsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  syncMsgsReq(const syncMsgsReq& from);
  syncMsgsReq(syncMsgsReq&& from) noexcept
    : syncMsgsReq() {
    *this = ::std::move(from);
  }

  inline syncMsgsReq& operator=(const syncMsgsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline syncMsgsReq& operator=(syncMsgsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const syncMsgsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const syncMsgsReq* internal_default_instance() {
    return reinterpret_cast<const syncMsgsReq*>(
               &_syncMsgsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(syncMsgsReq& a, syncMsgsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(syncMsgsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(syncMsgsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  syncMsgsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<syncMsgsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const syncMsgsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const syncMsgsReq& from) {
    syncMsgsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(syncMsgsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.syncMsgsReq";
  }
  protected:
  explicit syncMsgsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromUserIDFieldNumber = 1,
    kToUserIDFieldNumber = 2,
    kGroupIDFieldNumber = 3,
    kStartSeqFieldNumber = 5,
    kEndSeqFieldNumber = 6,
    kMsgTypeFieldNumber = 4,
  };
  // string fromUserID = 1;
  void clear_fromuserid() ;
  const std::string& fromuserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fromuserid(Arg_&& arg, Args_... args);
  std::string* mutable_fromuserid();
  PROTOBUF_NODISCARD std::string* release_fromuserid();
  void set_allocated_fromuserid(std::string* ptr);

  private:
  const std::string& _internal_fromuserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromuserid(
      const std::string& value);
  std::string* _internal_mutable_fromuserid();

  public:
  // string toUserID = 2;
  void clear_touserid() ;
  const std::string& touserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_touserid(Arg_&& arg, Args_... args);
  std::string* mutable_touserid();
  PROTOBUF_NODISCARD std::string* release_touserid();
  void set_allocated_touserid(std::string* ptr);

  private:
  const std::string& _internal_touserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_touserid(
      const std::string& value);
  std::string* _internal_mutable_touserid();

  public:
  // string groupID = 3;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // int64 startSeq = 5;
  void clear_startseq() ;
  ::int64_t startseq() const;
  void set_startseq(::int64_t value);

  private:
  ::int64_t _internal_startseq() const;
  void _internal_set_startseq(::int64_t value);

  public:
  // int64 endSeq = 6;
  void clear_endseq() ;
  ::int64_t endseq() const;
  void set_endseq(::int64_t value);

  private:
  ::int64_t _internal_endseq() const;
  void _internal_set_endseq(::int64_t value);

  public:
  // int32 msgType = 4;
  void clear_msgtype() ;
  ::int32_t msgtype() const;
  void set_msgtype(::int32_t value);

  private:
  ::int32_t _internal_msgtype() const;
  void _internal_set_msgtype(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.syncMsgsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromuserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr touserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::int64_t startseq_;
    ::int64_t endseq_;
    ::int32_t msgtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class syncMsgsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.syncMsgsResp) */ {
 public:
  inline syncMsgsResp() : syncMsgsResp(nullptr) {}
  ~syncMsgsResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR syncMsgsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  syncMsgsResp(const syncMsgsResp& from);
  syncMsgsResp(syncMsgsResp&& from) noexcept
    : syncMsgsResp() {
    *this = ::std::move(from);
  }

  inline syncMsgsResp& operator=(const syncMsgsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline syncMsgsResp& operator=(syncMsgsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const syncMsgsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const syncMsgsResp* internal_default_instance() {
    return reinterpret_cast<const syncMsgsResp*>(
               &_syncMsgsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(syncMsgsResp& a, syncMsgsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(syncMsgsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(syncMsgsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  syncMsgsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<syncMsgsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const syncMsgsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const syncMsgsResp& from) {
    syncMsgsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(syncMsgsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.syncMsgsResp";
  }
  protected:
  explicit syncMsgsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgsFieldNumber = 1,
  };
  // .ServerRpc.msg.pullMsgs msgs = 1;
  bool has_msgs() const;
  void clear_msgs() ;
  const ::ServerRpc::msg::pullMsgs& msgs() const;
  PROTOBUF_NODISCARD ::ServerRpc::msg::pullMsgs* release_msgs();
  ::ServerRpc::msg::pullMsgs* mutable_msgs();
  void set_allocated_msgs(::ServerRpc::msg::pullMsgs* msgs);
  private:
  const ::ServerRpc::msg::pullMsgs& _internal_msgs() const;
  ::ServerRpc::msg::pullMsgs* _internal_mutable_msgs();
  public:
  void unsafe_arena_set_allocated_msgs(
      ::ServerRpc::msg::pullMsgs* msgs);
  ::ServerRpc::msg::pullMsgs* unsafe_arena_release_msgs();
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.syncMsgsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ServerRpc::msg::pullMsgs* msgs_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// msg

// string fromUserID = 1;
inline void msg::clear_fromuserid() {
  _impl_.fromuserid_.ClearToEmpty();
}
inline const std::string& msg::fromuserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.fromUserID)
  return _internal_fromuserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msg::set_fromuserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fromuserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.fromUserID)
}
inline std::string* msg::mutable_fromuserid() {
  std::string* _s = _internal_mutable_fromuserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.msg.fromUserID)
  return _s;
}
inline const std::string& msg::_internal_fromuserid() const {
  return _impl_.fromuserid_.Get();
}
inline void msg::_internal_set_fromuserid(const std::string& value) {
  ;


  _impl_.fromuserid_.Set(value, GetArenaForAllocation());
}
inline std::string* msg::_internal_mutable_fromuserid() {
  ;
  return _impl_.fromuserid_.Mutable( GetArenaForAllocation());
}
inline std::string* msg::release_fromuserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.msg.fromUserID)
  return _impl_.fromuserid_.Release();
}
inline void msg::set_allocated_fromuserid(std::string* value) {
  _impl_.fromuserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fromuserid_.IsDefault()) {
          _impl_.fromuserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.msg.fromUserID)
}

// string toUserID = 2;
inline void msg::clear_touserid() {
  _impl_.touserid_.ClearToEmpty();
}
inline const std::string& msg::touserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.toUserID)
  return _internal_touserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msg::set_touserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.touserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.toUserID)
}
inline std::string* msg::mutable_touserid() {
  std::string* _s = _internal_mutable_touserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.msg.toUserID)
  return _s;
}
inline const std::string& msg::_internal_touserid() const {
  return _impl_.touserid_.Get();
}
inline void msg::_internal_set_touserid(const std::string& value) {
  ;


  _impl_.touserid_.Set(value, GetArenaForAllocation());
}
inline std::string* msg::_internal_mutable_touserid() {
  ;
  return _impl_.touserid_.Mutable( GetArenaForAllocation());
}
inline std::string* msg::release_touserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.msg.toUserID)
  return _impl_.touserid_.Release();
}
inline void msg::set_allocated_touserid(std::string* value) {
  _impl_.touserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.touserid_.IsDefault()) {
          _impl_.touserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.msg.toUserID)
}

// string groupID = 8;
inline void msg::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& msg::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msg::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.groupID)
}
inline std::string* msg::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.msg.groupID)
  return _s;
}
inline const std::string& msg::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void msg::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* msg::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* msg::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.msg.groupID)
  return _impl_.groupid_.Release();
}
inline void msg::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.msg.groupID)
}

// string content = 3;
inline void msg::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& msg::content() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msg::set_content(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.content)
}
inline std::string* msg::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.msg.content)
  return _s;
}
inline const std::string& msg::_internal_content() const {
  return _impl_.content_.Get();
}
inline void msg::_internal_set_content(const std::string& value) {
  ;


  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* msg::_internal_mutable_content() {
  ;
  return _impl_.content_.Mutable( GetArenaForAllocation());
}
inline std::string* msg::release_content() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.msg.content)
  return _impl_.content_.Release();
}
inline void msg::set_allocated_content(std::string* value) {
  _impl_.content_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.msg.content)
}

// int64 createTime = 4;
inline void msg::clear_createtime() {
  _impl_.createtime_ = ::int64_t{0};
}
inline ::int64_t msg::createtime() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.createTime)
  return _internal_createtime();
}
inline void msg::set_createtime(::int64_t value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.createTime)
}
inline ::int64_t msg::_internal_createtime() const {
  return _impl_.createtime_;
}
inline void msg::_internal_set_createtime(::int64_t value) {
  ;
  _impl_.createtime_ = value;
}

// int64 seq = 5;
inline void msg::clear_seq() {
  _impl_.seq_ = ::int64_t{0};
}
inline ::int64_t msg::seq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.seq)
  return _internal_seq();
}
inline void msg::set_seq(::int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.seq)
}
inline ::int64_t msg::_internal_seq() const {
  return _impl_.seq_;
}
inline void msg::_internal_set_seq(::int64_t value) {
  ;
  _impl_.seq_ = value;
}

// int32 platformID = 6;
inline void msg::clear_platformid() {
  _impl_.platformid_ = 0;
}
inline ::int32_t msg::platformid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.platformID)
  return _internal_platformid();
}
inline void msg::set_platformid(::int32_t value) {
  _internal_set_platformid(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.platformID)
}
inline ::int32_t msg::_internal_platformid() const {
  return _impl_.platformid_;
}
inline void msg::_internal_set_platformid(::int32_t value) {
  ;
  _impl_.platformid_ = value;
}

// int32 msgType = 7;
inline void msg::clear_msgtype() {
  _impl_.msgtype_ = 0;
}
inline ::int32_t msg::msgtype() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.msgType)
  return _internal_msgtype();
}
inline void msg::set_msgtype(::int32_t value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.msgType)
}
inline ::int32_t msg::_internal_msgtype() const {
  return _impl_.msgtype_;
}
inline void msg::_internal_set_msgtype(::int32_t value) {
  ;
  _impl_.msgtype_ = value;
}

// -------------------------------------------------------------------

// sendMsgReq

// .ServerRpc.msg.msg msg_data = 1;
inline bool sendMsgReq::has_msg_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.msg_data_ != nullptr);
  return value;
}
inline void sendMsgReq::clear_msg_data() {
  if (_impl_.msg_data_ != nullptr) _impl_.msg_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ServerRpc::msg::msg& sendMsgReq::_internal_msg_data() const {
  const ::ServerRpc::msg::msg* p = _impl_.msg_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerRpc::msg::msg&>(
      ::ServerRpc::msg::_msg_default_instance_);
}
inline const ::ServerRpc::msg::msg& sendMsgReq::msg_data() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.sendMsgReq.msg_data)
  return _internal_msg_data();
}
inline void sendMsgReq::unsafe_arena_set_allocated_msg_data(
    ::ServerRpc::msg::msg* msg_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msg_data_);
  }
  _impl_.msg_data_ = msg_data;
  if (msg_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerRpc.msg.sendMsgReq.msg_data)
}
inline ::ServerRpc::msg::msg* sendMsgReq::release_msg_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::msg::msg* temp = _impl_.msg_data_;
  _impl_.msg_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerRpc::msg::msg* sendMsgReq::unsafe_arena_release_msg_data() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.sendMsgReq.msg_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::msg::msg* temp = _impl_.msg_data_;
  _impl_.msg_data_ = nullptr;
  return temp;
}
inline ::ServerRpc::msg::msg* sendMsgReq::_internal_mutable_msg_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.msg_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerRpc::msg::msg>(GetArenaForAllocation());
    _impl_.msg_data_ = p;
  }
  return _impl_.msg_data_;
}
inline ::ServerRpc::msg::msg* sendMsgReq::mutable_msg_data() {
  ::ServerRpc::msg::msg* _msg = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.sendMsgReq.msg_data)
  return _msg;
}
inline void sendMsgReq::set_allocated_msg_data(::ServerRpc::msg::msg* msg_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.msg_data_;
  }
  if (msg_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg_data);
    if (message_arena != submessage_arena) {
      msg_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_data_ = msg_data;
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.sendMsgReq.msg_data)
}

// -------------------------------------------------------------------

// sendMsgResp

// int64 sendTime = 1;
inline void sendMsgResp::clear_sendtime() {
  _impl_.sendtime_ = ::int64_t{0};
}
inline ::int64_t sendMsgResp::sendtime() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.sendMsgResp.sendTime)
  return _internal_sendtime();
}
inline void sendMsgResp::set_sendtime(::int64_t value) {
  _internal_set_sendtime(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.sendMsgResp.sendTime)
}
inline ::int64_t sendMsgResp::_internal_sendtime() const {
  return _impl_.sendtime_;
}
inline void sendMsgResp::_internal_set_sendtime(::int64_t value) {
  ;
  _impl_.sendtime_ = value;
}

// -------------------------------------------------------------------

// pullMsgs

// repeated .ServerRpc.msg.msg msgs = 1;
inline int pullMsgs::_internal_msgs_size() const {
  return _impl_.msgs_.size();
}
inline int pullMsgs::msgs_size() const {
  return _internal_msgs_size();
}
inline void pullMsgs::clear_msgs() {
  _internal_mutable_msgs()->Clear();
}
inline ::ServerRpc::msg::msg* pullMsgs::mutable_msgs(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.pullMsgs.msgs)
  return _internal_mutable_msgs()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::msg::msg >*
pullMsgs::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.msg.pullMsgs.msgs)
  return _internal_mutable_msgs();
}
inline const ::ServerRpc::msg::msg& pullMsgs::_internal_msgs(int index) const {
  return _internal_msgs().Get(index);
}
inline const ::ServerRpc::msg::msg& pullMsgs::msgs(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.pullMsgs.msgs)
  return _internal_msgs(index);
}
inline ::ServerRpc::msg::msg* pullMsgs::_internal_add_msgs() {
  return _internal_mutable_msgs()->Add();
}
inline ::ServerRpc::msg::msg* pullMsgs::add_msgs() {
  ::ServerRpc::msg::msg* _add = _internal_add_msgs();
  // @@protoc_insertion_point(field_add:ServerRpc.msg.pullMsgs.msgs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::msg::msg >&
pullMsgs::msgs() const {
  // @@protoc_insertion_point(field_list:ServerRpc.msg.pullMsgs.msgs)
  return _internal_msgs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::msg::msg>&
pullMsgs::_internal_msgs() const {
  return _impl_.msgs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::msg::msg>*
pullMsgs::_internal_mutable_msgs() {
  return &_impl_.msgs_;
}

// -------------------------------------------------------------------

// setHasReadSeqReq

// string fromUserID = 1;
inline void setHasReadSeqReq::clear_fromuserid() {
  _impl_.fromuserid_.ClearToEmpty();
}
inline const std::string& setHasReadSeqReq::fromuserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.setHasReadSeqReq.fromUserID)
  return _internal_fromuserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void setHasReadSeqReq::set_fromuserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fromuserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.setHasReadSeqReq.fromUserID)
}
inline std::string* setHasReadSeqReq::mutable_fromuserid() {
  std::string* _s = _internal_mutable_fromuserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.setHasReadSeqReq.fromUserID)
  return _s;
}
inline const std::string& setHasReadSeqReq::_internal_fromuserid() const {
  return _impl_.fromuserid_.Get();
}
inline void setHasReadSeqReq::_internal_set_fromuserid(const std::string& value) {
  ;


  _impl_.fromuserid_.Set(value, GetArenaForAllocation());
}
inline std::string* setHasReadSeqReq::_internal_mutable_fromuserid() {
  ;
  return _impl_.fromuserid_.Mutable( GetArenaForAllocation());
}
inline std::string* setHasReadSeqReq::release_fromuserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.setHasReadSeqReq.fromUserID)
  return _impl_.fromuserid_.Release();
}
inline void setHasReadSeqReq::set_allocated_fromuserid(std::string* value) {
  _impl_.fromuserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fromuserid_.IsDefault()) {
          _impl_.fromuserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.setHasReadSeqReq.fromUserID)
}

// string toUserID = 2;
inline void setHasReadSeqReq::clear_touserid() {
  _impl_.touserid_.ClearToEmpty();
}
inline const std::string& setHasReadSeqReq::touserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.setHasReadSeqReq.toUserID)
  return _internal_touserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void setHasReadSeqReq::set_touserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.touserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.setHasReadSeqReq.toUserID)
}
inline std::string* setHasReadSeqReq::mutable_touserid() {
  std::string* _s = _internal_mutable_touserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.setHasReadSeqReq.toUserID)
  return _s;
}
inline const std::string& setHasReadSeqReq::_internal_touserid() const {
  return _impl_.touserid_.Get();
}
inline void setHasReadSeqReq::_internal_set_touserid(const std::string& value) {
  ;


  _impl_.touserid_.Set(value, GetArenaForAllocation());
}
inline std::string* setHasReadSeqReq::_internal_mutable_touserid() {
  ;
  return _impl_.touserid_.Mutable( GetArenaForAllocation());
}
inline std::string* setHasReadSeqReq::release_touserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.setHasReadSeqReq.toUserID)
  return _impl_.touserid_.Release();
}
inline void setHasReadSeqReq::set_allocated_touserid(std::string* value) {
  _impl_.touserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.touserid_.IsDefault()) {
          _impl_.touserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.setHasReadSeqReq.toUserID)
}

// string groupID = 3;
inline void setHasReadSeqReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& setHasReadSeqReq::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.setHasReadSeqReq.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void setHasReadSeqReq::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.setHasReadSeqReq.groupID)
}
inline std::string* setHasReadSeqReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.setHasReadSeqReq.groupID)
  return _s;
}
inline const std::string& setHasReadSeqReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void setHasReadSeqReq::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* setHasReadSeqReq::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* setHasReadSeqReq::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.setHasReadSeqReq.groupID)
  return _impl_.groupid_.Release();
}
inline void setHasReadSeqReq::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.setHasReadSeqReq.groupID)
}

// int32 msgType = 4;
inline void setHasReadSeqReq::clear_msgtype() {
  _impl_.msgtype_ = 0;
}
inline ::int32_t setHasReadSeqReq::msgtype() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.setHasReadSeqReq.msgType)
  return _internal_msgtype();
}
inline void setHasReadSeqReq::set_msgtype(::int32_t value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.setHasReadSeqReq.msgType)
}
inline ::int32_t setHasReadSeqReq::_internal_msgtype() const {
  return _impl_.msgtype_;
}
inline void setHasReadSeqReq::_internal_set_msgtype(::int32_t value) {
  ;
  _impl_.msgtype_ = value;
}

// int64 seq = 5;
inline void setHasReadSeqReq::clear_seq() {
  _impl_.seq_ = ::int64_t{0};
}
inline ::int64_t setHasReadSeqReq::seq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.setHasReadSeqReq.seq)
  return _internal_seq();
}
inline void setHasReadSeqReq::set_seq(::int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.setHasReadSeqReq.seq)
}
inline ::int64_t setHasReadSeqReq::_internal_seq() const {
  return _impl_.seq_;
}
inline void setHasReadSeqReq::_internal_set_seq(::int64_t value) {
  ;
  _impl_.seq_ = value;
}

// -------------------------------------------------------------------

// setHasReadSeqResp

// int64 sendTime = 1;
inline void setHasReadSeqResp::clear_sendtime() {
  _impl_.sendtime_ = ::int64_t{0};
}
inline ::int64_t setHasReadSeqResp::sendtime() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.setHasReadSeqResp.sendTime)
  return _internal_sendtime();
}
inline void setHasReadSeqResp::set_sendtime(::int64_t value) {
  _internal_set_sendtime(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.setHasReadSeqResp.sendTime)
}
inline ::int64_t setHasReadSeqResp::_internal_sendtime() const {
  return _impl_.sendtime_;
}
inline void setHasReadSeqResp::_internal_set_sendtime(::int64_t value) {
  ;
  _impl_.sendtime_ = value;
}

// -------------------------------------------------------------------

// getHasReadSeqAndMaxSeqReq

// string fromUserID = 1;
inline void getHasReadSeqAndMaxSeqReq::clear_fromuserid() {
  _impl_.fromuserid_.ClearToEmpty();
}
inline const std::string& getHasReadSeqAndMaxSeqReq::fromuserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.fromUserID)
  return _internal_fromuserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getHasReadSeqAndMaxSeqReq::set_fromuserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fromuserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.fromUserID)
}
inline std::string* getHasReadSeqAndMaxSeqReq::mutable_fromuserid() {
  std::string* _s = _internal_mutable_fromuserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.fromUserID)
  return _s;
}
inline const std::string& getHasReadSeqAndMaxSeqReq::_internal_fromuserid() const {
  return _impl_.fromuserid_.Get();
}
inline void getHasReadSeqAndMaxSeqReq::_internal_set_fromuserid(const std::string& value) {
  ;


  _impl_.fromuserid_.Set(value, GetArenaForAllocation());
}
inline std::string* getHasReadSeqAndMaxSeqReq::_internal_mutable_fromuserid() {
  ;
  return _impl_.fromuserid_.Mutable( GetArenaForAllocation());
}
inline std::string* getHasReadSeqAndMaxSeqReq::release_fromuserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.fromUserID)
  return _impl_.fromuserid_.Release();
}
inline void getHasReadSeqAndMaxSeqReq::set_allocated_fromuserid(std::string* value) {
  _impl_.fromuserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fromuserid_.IsDefault()) {
          _impl_.fromuserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.fromUserID)
}

// string toUserID = 2;
inline void getHasReadSeqAndMaxSeqReq::clear_touserid() {
  _impl_.touserid_.ClearToEmpty();
}
inline const std::string& getHasReadSeqAndMaxSeqReq::touserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.toUserID)
  return _internal_touserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getHasReadSeqAndMaxSeqReq::set_touserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.touserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.toUserID)
}
inline std::string* getHasReadSeqAndMaxSeqReq::mutable_touserid() {
  std::string* _s = _internal_mutable_touserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.toUserID)
  return _s;
}
inline const std::string& getHasReadSeqAndMaxSeqReq::_internal_touserid() const {
  return _impl_.touserid_.Get();
}
inline void getHasReadSeqAndMaxSeqReq::_internal_set_touserid(const std::string& value) {
  ;


  _impl_.touserid_.Set(value, GetArenaForAllocation());
}
inline std::string* getHasReadSeqAndMaxSeqReq::_internal_mutable_touserid() {
  ;
  return _impl_.touserid_.Mutable( GetArenaForAllocation());
}
inline std::string* getHasReadSeqAndMaxSeqReq::release_touserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.toUserID)
  return _impl_.touserid_.Release();
}
inline void getHasReadSeqAndMaxSeqReq::set_allocated_touserid(std::string* value) {
  _impl_.touserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.touserid_.IsDefault()) {
          _impl_.touserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.toUserID)
}

// string groupID = 3;
inline void getHasReadSeqAndMaxSeqReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& getHasReadSeqAndMaxSeqReq::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getHasReadSeqAndMaxSeqReq::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.groupID)
}
inline std::string* getHasReadSeqAndMaxSeqReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.groupID)
  return _s;
}
inline const std::string& getHasReadSeqAndMaxSeqReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void getHasReadSeqAndMaxSeqReq::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* getHasReadSeqAndMaxSeqReq::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* getHasReadSeqAndMaxSeqReq::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.groupID)
  return _impl_.groupid_.Release();
}
inline void getHasReadSeqAndMaxSeqReq::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.groupID)
}

// int32 msgType = 4;
inline void getHasReadSeqAndMaxSeqReq::clear_msgtype() {
  _impl_.msgtype_ = 0;
}
inline ::int32_t getHasReadSeqAndMaxSeqReq::msgtype() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.msgType)
  return _internal_msgtype();
}
inline void getHasReadSeqAndMaxSeqReq::set_msgtype(::int32_t value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.getHasReadSeqAndMaxSeqReq.msgType)
}
inline ::int32_t getHasReadSeqAndMaxSeqReq::_internal_msgtype() const {
  return _impl_.msgtype_;
}
inline void getHasReadSeqAndMaxSeqReq::_internal_set_msgtype(::int32_t value) {
  ;
  _impl_.msgtype_ = value;
}

// -------------------------------------------------------------------

// getHasReadSeqAndMaxSeqResp

// int64 hasReadSeq = 1;
inline void getHasReadSeqAndMaxSeqResp::clear_hasreadseq() {
  _impl_.hasreadseq_ = ::int64_t{0};
}
inline ::int64_t getHasReadSeqAndMaxSeqResp::hasreadseq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.getHasReadSeqAndMaxSeqResp.hasReadSeq)
  return _internal_hasreadseq();
}
inline void getHasReadSeqAndMaxSeqResp::set_hasreadseq(::int64_t value) {
  _internal_set_hasreadseq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.getHasReadSeqAndMaxSeqResp.hasReadSeq)
}
inline ::int64_t getHasReadSeqAndMaxSeqResp::_internal_hasreadseq() const {
  return _impl_.hasreadseq_;
}
inline void getHasReadSeqAndMaxSeqResp::_internal_set_hasreadseq(::int64_t value) {
  ;
  _impl_.hasreadseq_ = value;
}

// int64 maxSeq = 2;
inline void getHasReadSeqAndMaxSeqResp::clear_maxseq() {
  _impl_.maxseq_ = ::int64_t{0};
}
inline ::int64_t getHasReadSeqAndMaxSeqResp::maxseq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.getHasReadSeqAndMaxSeqResp.maxSeq)
  return _internal_maxseq();
}
inline void getHasReadSeqAndMaxSeqResp::set_maxseq(::int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.getHasReadSeqAndMaxSeqResp.maxSeq)
}
inline ::int64_t getHasReadSeqAndMaxSeqResp::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline void getHasReadSeqAndMaxSeqResp::_internal_set_maxseq(::int64_t value) {
  ;
  _impl_.maxseq_ = value;
}

// -------------------------------------------------------------------

// syncMsgsReq

// string fromUserID = 1;
inline void syncMsgsReq::clear_fromuserid() {
  _impl_.fromuserid_.ClearToEmpty();
}
inline const std::string& syncMsgsReq::fromuserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.syncMsgsReq.fromUserID)
  return _internal_fromuserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void syncMsgsReq::set_fromuserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fromuserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.syncMsgsReq.fromUserID)
}
inline std::string* syncMsgsReq::mutable_fromuserid() {
  std::string* _s = _internal_mutable_fromuserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.syncMsgsReq.fromUserID)
  return _s;
}
inline const std::string& syncMsgsReq::_internal_fromuserid() const {
  return _impl_.fromuserid_.Get();
}
inline void syncMsgsReq::_internal_set_fromuserid(const std::string& value) {
  ;


  _impl_.fromuserid_.Set(value, GetArenaForAllocation());
}
inline std::string* syncMsgsReq::_internal_mutable_fromuserid() {
  ;
  return _impl_.fromuserid_.Mutable( GetArenaForAllocation());
}
inline std::string* syncMsgsReq::release_fromuserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.syncMsgsReq.fromUserID)
  return _impl_.fromuserid_.Release();
}
inline void syncMsgsReq::set_allocated_fromuserid(std::string* value) {
  _impl_.fromuserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fromuserid_.IsDefault()) {
          _impl_.fromuserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.syncMsgsReq.fromUserID)
}

// string toUserID = 2;
inline void syncMsgsReq::clear_touserid() {
  _impl_.touserid_.ClearToEmpty();
}
inline const std::string& syncMsgsReq::touserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.syncMsgsReq.toUserID)
  return _internal_touserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void syncMsgsReq::set_touserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.touserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.syncMsgsReq.toUserID)
}
inline std::string* syncMsgsReq::mutable_touserid() {
  std::string* _s = _internal_mutable_touserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.syncMsgsReq.toUserID)
  return _s;
}
inline const std::string& syncMsgsReq::_internal_touserid() const {
  return _impl_.touserid_.Get();
}
inline void syncMsgsReq::_internal_set_touserid(const std::string& value) {
  ;


  _impl_.touserid_.Set(value, GetArenaForAllocation());
}
inline std::string* syncMsgsReq::_internal_mutable_touserid() {
  ;
  return _impl_.touserid_.Mutable( GetArenaForAllocation());
}
inline std::string* syncMsgsReq::release_touserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.syncMsgsReq.toUserID)
  return _impl_.touserid_.Release();
}
inline void syncMsgsReq::set_allocated_touserid(std::string* value) {
  _impl_.touserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.touserid_.IsDefault()) {
          _impl_.touserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.syncMsgsReq.toUserID)
}

// string groupID = 3;
inline void syncMsgsReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& syncMsgsReq::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.syncMsgsReq.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void syncMsgsReq::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.syncMsgsReq.groupID)
}
inline std::string* syncMsgsReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.syncMsgsReq.groupID)
  return _s;
}
inline const std::string& syncMsgsReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void syncMsgsReq::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* syncMsgsReq::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* syncMsgsReq::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.syncMsgsReq.groupID)
  return _impl_.groupid_.Release();
}
inline void syncMsgsReq::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.syncMsgsReq.groupID)
}

// int32 msgType = 4;
inline void syncMsgsReq::clear_msgtype() {
  _impl_.msgtype_ = 0;
}
inline ::int32_t syncMsgsReq::msgtype() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.syncMsgsReq.msgType)
  return _internal_msgtype();
}
inline void syncMsgsReq::set_msgtype(::int32_t value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.syncMsgsReq.msgType)
}
inline ::int32_t syncMsgsReq::_internal_msgtype() const {
  return _impl_.msgtype_;
}
inline void syncMsgsReq::_internal_set_msgtype(::int32_t value) {
  ;
  _impl_.msgtype_ = value;
}

// int64 startSeq = 5;
inline void syncMsgsReq::clear_startseq() {
  _impl_.startseq_ = ::int64_t{0};
}
inline ::int64_t syncMsgsReq::startseq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.syncMsgsReq.startSeq)
  return _internal_startseq();
}
inline void syncMsgsReq::set_startseq(::int64_t value) {
  _internal_set_startseq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.syncMsgsReq.startSeq)
}
inline ::int64_t syncMsgsReq::_internal_startseq() const {
  return _impl_.startseq_;
}
inline void syncMsgsReq::_internal_set_startseq(::int64_t value) {
  ;
  _impl_.startseq_ = value;
}

// int64 endSeq = 6;
inline void syncMsgsReq::clear_endseq() {
  _impl_.endseq_ = ::int64_t{0};
}
inline ::int64_t syncMsgsReq::endseq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.syncMsgsReq.endSeq)
  return _internal_endseq();
}
inline void syncMsgsReq::set_endseq(::int64_t value) {
  _internal_set_endseq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.syncMsgsReq.endSeq)
}
inline ::int64_t syncMsgsReq::_internal_endseq() const {
  return _impl_.endseq_;
}
inline void syncMsgsReq::_internal_set_endseq(::int64_t value) {
  ;
  _impl_.endseq_ = value;
}

// -------------------------------------------------------------------

// syncMsgsResp

// .ServerRpc.msg.pullMsgs msgs = 1;
inline bool syncMsgsResp::has_msgs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.msgs_ != nullptr);
  return value;
}
inline void syncMsgsResp::clear_msgs() {
  if (_impl_.msgs_ != nullptr) _impl_.msgs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ServerRpc::msg::pullMsgs& syncMsgsResp::_internal_msgs() const {
  const ::ServerRpc::msg::pullMsgs* p = _impl_.msgs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerRpc::msg::pullMsgs&>(
      ::ServerRpc::msg::_pullMsgs_default_instance_);
}
inline const ::ServerRpc::msg::pullMsgs& syncMsgsResp::msgs() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.syncMsgsResp.msgs)
  return _internal_msgs();
}
inline void syncMsgsResp::unsafe_arena_set_allocated_msgs(
    ::ServerRpc::msg::pullMsgs* msgs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgs_);
  }
  _impl_.msgs_ = msgs;
  if (msgs) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerRpc.msg.syncMsgsResp.msgs)
}
inline ::ServerRpc::msg::pullMsgs* syncMsgsResp::release_msgs() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::msg::pullMsgs* temp = _impl_.msgs_;
  _impl_.msgs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerRpc::msg::pullMsgs* syncMsgsResp::unsafe_arena_release_msgs() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.syncMsgsResp.msgs)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::msg::pullMsgs* temp = _impl_.msgs_;
  _impl_.msgs_ = nullptr;
  return temp;
}
inline ::ServerRpc::msg::pullMsgs* syncMsgsResp::_internal_mutable_msgs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.msgs_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerRpc::msg::pullMsgs>(GetArenaForAllocation());
    _impl_.msgs_ = p;
  }
  return _impl_.msgs_;
}
inline ::ServerRpc::msg::pullMsgs* syncMsgsResp::mutable_msgs() {
  ::ServerRpc::msg::pullMsgs* _msg = _internal_mutable_msgs();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.syncMsgsResp.msgs)
  return _msg;
}
inline void syncMsgsResp::set_allocated_msgs(::ServerRpc::msg::pullMsgs* msgs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.msgs_;
  }
  if (msgs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msgs);
    if (message_arena != submessage_arena) {
      msgs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msgs_ = msgs;
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.syncMsgsResp.msgs)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace msg
}  // namespace ServerRpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_msg_2eproto_2epb_2eh
