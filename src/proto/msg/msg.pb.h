// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_msg_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_msg_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_msg_2eproto;
namespace ServerRpc {
namespace msg {
class msg;
struct msgDefaultTypeInternal;
extern msgDefaultTypeInternal _msg_default_instance_;
class sendMsgReq;
struct sendMsgReqDefaultTypeInternal;
extern sendMsgReqDefaultTypeInternal _sendMsgReq_default_instance_;
class sendMsgResp;
struct sendMsgRespDefaultTypeInternal;
extern sendMsgRespDefaultTypeInternal _sendMsgResp_default_instance_;
}  // namespace msg
}  // namespace ServerRpc
PROTOBUF_NAMESPACE_OPEN
template <>
::ServerRpc::msg::msg* Arena::CreateMaybeMessage<::ServerRpc::msg::msg>(Arena*);
template <>
::ServerRpc::msg::sendMsgReq* Arena::CreateMaybeMessage<::ServerRpc::msg::sendMsgReq>(Arena*);
template <>
::ServerRpc::msg::sendMsgResp* Arena::CreateMaybeMessage<::ServerRpc::msg::sendMsgResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace ServerRpc {
namespace msg {

// ===================================================================


// -------------------------------------------------------------------

class msg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.msg) */ {
 public:
  inline msg() : msg(nullptr) {}
  ~msg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR msg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  msg(const msg& from);
  msg(msg&& from) noexcept
    : msg() {
    *this = ::std::move(from);
  }

  inline msg& operator=(const msg& from) {
    CopyFrom(from);
    return *this;
  }
  inline msg& operator=(msg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const msg& default_instance() {
    return *internal_default_instance();
  }
  static inline const msg* internal_default_instance() {
    return reinterpret_cast<const msg*>(
               &_msg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(msg& a, msg& b) {
    a.Swap(&b);
  }
  inline void Swap(msg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(msg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  msg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<msg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const msg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const msg& from) {
    msg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(msg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.msg";
  }
  protected:
  explicit msg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromUserIDFieldNumber = 1,
    kToUserIDFieldNumber = 2,
    kContentFieldNumber = 3,
    kGroupIDFieldNumber = 8,
    kCreateTimeFieldNumber = 4,
    kSeqFieldNumber = 5,
    kPlatformIDFieldNumber = 6,
    kMsgTypeFieldNumber = 7,
  };
  // string fromUserID = 1;
  void clear_fromuserid() ;
  const std::string& fromuserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fromuserid(Arg_&& arg, Args_... args);
  std::string* mutable_fromuserid();
  PROTOBUF_NODISCARD std::string* release_fromuserid();
  void set_allocated_fromuserid(std::string* ptr);

  private:
  const std::string& _internal_fromuserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromuserid(
      const std::string& value);
  std::string* _internal_mutable_fromuserid();

  public:
  // string toUserID = 2;
  void clear_touserid() ;
  const std::string& touserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_touserid(Arg_&& arg, Args_... args);
  std::string* mutable_touserid();
  PROTOBUF_NODISCARD std::string* release_touserid();
  void set_allocated_touserid(std::string* ptr);

  private:
  const std::string& _internal_touserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_touserid(
      const std::string& value);
  std::string* _internal_mutable_touserid();

  public:
  // string content = 3;
  void clear_content() ;
  const std::string& content() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* ptr);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // string groupID = 8;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // int64 createTime = 4;
  void clear_createtime() ;
  ::int64_t createtime() const;
  void set_createtime(::int64_t value);

  private:
  ::int64_t _internal_createtime() const;
  void _internal_set_createtime(::int64_t value);

  public:
  // int64 seq = 5;
  void clear_seq() ;
  ::int64_t seq() const;
  void set_seq(::int64_t value);

  private:
  ::int64_t _internal_seq() const;
  void _internal_set_seq(::int64_t value);

  public:
  // int32 platformID = 6;
  void clear_platformid() ;
  ::int32_t platformid() const;
  void set_platformid(::int32_t value);

  private:
  ::int32_t _internal_platformid() const;
  void _internal_set_platformid(::int32_t value);

  public:
  // int32 msgType = 7;
  void clear_msgtype() ;
  ::int32_t msgtype() const;
  void set_msgtype(::int32_t value);

  private:
  ::int32_t _internal_msgtype() const;
  void _internal_set_msgtype(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.msg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromuserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr touserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::int64_t createtime_;
    ::int64_t seq_;
    ::int32_t platformid_;
    ::int32_t msgtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class sendMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.sendMsgReq) */ {
 public:
  inline sendMsgReq() : sendMsgReq(nullptr) {}
  ~sendMsgReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR sendMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  sendMsgReq(const sendMsgReq& from);
  sendMsgReq(sendMsgReq&& from) noexcept
    : sendMsgReq() {
    *this = ::std::move(from);
  }

  inline sendMsgReq& operator=(const sendMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline sendMsgReq& operator=(sendMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const sendMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const sendMsgReq* internal_default_instance() {
    return reinterpret_cast<const sendMsgReq*>(
               &_sendMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(sendMsgReq& a, sendMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(sendMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sendMsgReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  sendMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<sendMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const sendMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const sendMsgReq& from) {
    sendMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sendMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.sendMsgReq";
  }
  protected:
  explicit sendMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 1,
  };
  // .ServerRpc.msg.msg msg_data = 1;
  bool has_msg_data() const;
  void clear_msg_data() ;
  const ::ServerRpc::msg::msg& msg_data() const;
  PROTOBUF_NODISCARD ::ServerRpc::msg::msg* release_msg_data();
  ::ServerRpc::msg::msg* mutable_msg_data();
  void set_allocated_msg_data(::ServerRpc::msg::msg* msg_data);
  private:
  const ::ServerRpc::msg::msg& _internal_msg_data() const;
  ::ServerRpc::msg::msg* _internal_mutable_msg_data();
  public:
  void unsafe_arena_set_allocated_msg_data(
      ::ServerRpc::msg::msg* msg_data);
  ::ServerRpc::msg::msg* unsafe_arena_release_msg_data();
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.sendMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ServerRpc::msg::msg* msg_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};// -------------------------------------------------------------------

class sendMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.msg.sendMsgResp) */ {
 public:
  inline sendMsgResp() : sendMsgResp(nullptr) {}
  ~sendMsgResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR sendMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  sendMsgResp(const sendMsgResp& from);
  sendMsgResp(sendMsgResp&& from) noexcept
    : sendMsgResp() {
    *this = ::std::move(from);
  }

  inline sendMsgResp& operator=(const sendMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline sendMsgResp& operator=(sendMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const sendMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const sendMsgResp* internal_default_instance() {
    return reinterpret_cast<const sendMsgResp*>(
               &_sendMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(sendMsgResp& a, sendMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(sendMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sendMsgResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  sendMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<sendMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const sendMsgResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const sendMsgResp& from) {
    sendMsgResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sendMsgResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.msg.sendMsgResp";
  }
  protected:
  explicit sendMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendTimeFieldNumber = 1,
  };
  // int64 sendTime = 1;
  void clear_sendtime() ;
  ::int64_t sendtime() const;
  void set_sendtime(::int64_t value);

  private:
  ::int64_t _internal_sendtime() const;
  void _internal_set_sendtime(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.msg.sendMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t sendtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// msg

// string fromUserID = 1;
inline void msg::clear_fromuserid() {
  _impl_.fromuserid_.ClearToEmpty();
}
inline const std::string& msg::fromuserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.fromUserID)
  return _internal_fromuserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msg::set_fromuserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fromuserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.fromUserID)
}
inline std::string* msg::mutable_fromuserid() {
  std::string* _s = _internal_mutable_fromuserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.msg.fromUserID)
  return _s;
}
inline const std::string& msg::_internal_fromuserid() const {
  return _impl_.fromuserid_.Get();
}
inline void msg::_internal_set_fromuserid(const std::string& value) {
  ;


  _impl_.fromuserid_.Set(value, GetArenaForAllocation());
}
inline std::string* msg::_internal_mutable_fromuserid() {
  ;
  return _impl_.fromuserid_.Mutable( GetArenaForAllocation());
}
inline std::string* msg::release_fromuserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.msg.fromUserID)
  return _impl_.fromuserid_.Release();
}
inline void msg::set_allocated_fromuserid(std::string* value) {
  _impl_.fromuserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fromuserid_.IsDefault()) {
          _impl_.fromuserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.msg.fromUserID)
}

// string toUserID = 2;
inline void msg::clear_touserid() {
  _impl_.touserid_.ClearToEmpty();
}
inline const std::string& msg::touserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.toUserID)
  return _internal_touserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msg::set_touserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.touserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.toUserID)
}
inline std::string* msg::mutable_touserid() {
  std::string* _s = _internal_mutable_touserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.msg.toUserID)
  return _s;
}
inline const std::string& msg::_internal_touserid() const {
  return _impl_.touserid_.Get();
}
inline void msg::_internal_set_touserid(const std::string& value) {
  ;


  _impl_.touserid_.Set(value, GetArenaForAllocation());
}
inline std::string* msg::_internal_mutable_touserid() {
  ;
  return _impl_.touserid_.Mutable( GetArenaForAllocation());
}
inline std::string* msg::release_touserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.msg.toUserID)
  return _impl_.touserid_.Release();
}
inline void msg::set_allocated_touserid(std::string* value) {
  _impl_.touserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.touserid_.IsDefault()) {
          _impl_.touserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.msg.toUserID)
}

// string groupID = 8;
inline void msg::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& msg::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msg::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.groupID)
}
inline std::string* msg::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.msg.groupID)
  return _s;
}
inline const std::string& msg::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void msg::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* msg::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* msg::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.msg.groupID)
  return _impl_.groupid_.Release();
}
inline void msg::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.msg.groupID)
}

// string content = 3;
inline void msg::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& msg::content() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msg::set_content(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.content)
}
inline std::string* msg::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.msg.content)
  return _s;
}
inline const std::string& msg::_internal_content() const {
  return _impl_.content_.Get();
}
inline void msg::_internal_set_content(const std::string& value) {
  ;


  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* msg::_internal_mutable_content() {
  ;
  return _impl_.content_.Mutable( GetArenaForAllocation());
}
inline std::string* msg::release_content() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.msg.content)
  return _impl_.content_.Release();
}
inline void msg::set_allocated_content(std::string* value) {
  _impl_.content_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.msg.content)
}

// int64 createTime = 4;
inline void msg::clear_createtime() {
  _impl_.createtime_ = ::int64_t{0};
}
inline ::int64_t msg::createtime() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.createTime)
  return _internal_createtime();
}
inline void msg::set_createtime(::int64_t value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.createTime)
}
inline ::int64_t msg::_internal_createtime() const {
  return _impl_.createtime_;
}
inline void msg::_internal_set_createtime(::int64_t value) {
  ;
  _impl_.createtime_ = value;
}

// int64 seq = 5;
inline void msg::clear_seq() {
  _impl_.seq_ = ::int64_t{0};
}
inline ::int64_t msg::seq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.seq)
  return _internal_seq();
}
inline void msg::set_seq(::int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.seq)
}
inline ::int64_t msg::_internal_seq() const {
  return _impl_.seq_;
}
inline void msg::_internal_set_seq(::int64_t value) {
  ;
  _impl_.seq_ = value;
}

// int32 platformID = 6;
inline void msg::clear_platformid() {
  _impl_.platformid_ = 0;
}
inline ::int32_t msg::platformid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.platformID)
  return _internal_platformid();
}
inline void msg::set_platformid(::int32_t value) {
  _internal_set_platformid(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.platformID)
}
inline ::int32_t msg::_internal_platformid() const {
  return _impl_.platformid_;
}
inline void msg::_internal_set_platformid(::int32_t value) {
  ;
  _impl_.platformid_ = value;
}

// int32 msgType = 7;
inline void msg::clear_msgtype() {
  _impl_.msgtype_ = 0;
}
inline ::int32_t msg::msgtype() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.msg.msgType)
  return _internal_msgtype();
}
inline void msg::set_msgtype(::int32_t value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.msg.msgType)
}
inline ::int32_t msg::_internal_msgtype() const {
  return _impl_.msgtype_;
}
inline void msg::_internal_set_msgtype(::int32_t value) {
  ;
  _impl_.msgtype_ = value;
}

// -------------------------------------------------------------------

// sendMsgReq

// .ServerRpc.msg.msg msg_data = 1;
inline bool sendMsgReq::has_msg_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.msg_data_ != nullptr);
  return value;
}
inline void sendMsgReq::clear_msg_data() {
  if (_impl_.msg_data_ != nullptr) _impl_.msg_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ServerRpc::msg::msg& sendMsgReq::_internal_msg_data() const {
  const ::ServerRpc::msg::msg* p = _impl_.msg_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerRpc::msg::msg&>(
      ::ServerRpc::msg::_msg_default_instance_);
}
inline const ::ServerRpc::msg::msg& sendMsgReq::msg_data() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.sendMsgReq.msg_data)
  return _internal_msg_data();
}
inline void sendMsgReq::unsafe_arena_set_allocated_msg_data(
    ::ServerRpc::msg::msg* msg_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msg_data_);
  }
  _impl_.msg_data_ = msg_data;
  if (msg_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerRpc.msg.sendMsgReq.msg_data)
}
inline ::ServerRpc::msg::msg* sendMsgReq::release_msg_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::msg::msg* temp = _impl_.msg_data_;
  _impl_.msg_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerRpc::msg::msg* sendMsgReq::unsafe_arena_release_msg_data() {
  // @@protoc_insertion_point(field_release:ServerRpc.msg.sendMsgReq.msg_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::msg::msg* temp = _impl_.msg_data_;
  _impl_.msg_data_ = nullptr;
  return temp;
}
inline ::ServerRpc::msg::msg* sendMsgReq::_internal_mutable_msg_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.msg_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerRpc::msg::msg>(GetArenaForAllocation());
    _impl_.msg_data_ = p;
  }
  return _impl_.msg_data_;
}
inline ::ServerRpc::msg::msg* sendMsgReq::mutable_msg_data() {
  ::ServerRpc::msg::msg* _msg = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:ServerRpc.msg.sendMsgReq.msg_data)
  return _msg;
}
inline void sendMsgReq::set_allocated_msg_data(::ServerRpc::msg::msg* msg_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.msg_data_;
  }
  if (msg_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg_data);
    if (message_arena != submessage_arena) {
      msg_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_data_ = msg_data;
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.msg.sendMsgReq.msg_data)
}

// -------------------------------------------------------------------

// sendMsgResp

// int64 sendTime = 1;
inline void sendMsgResp::clear_sendtime() {
  _impl_.sendtime_ = ::int64_t{0};
}
inline ::int64_t sendMsgResp::sendtime() const {
  // @@protoc_insertion_point(field_get:ServerRpc.msg.sendMsgResp.sendTime)
  return _internal_sendtime();
}
inline void sendMsgResp::set_sendtime(::int64_t value) {
  _internal_set_sendtime(value);
  // @@protoc_insertion_point(field_set:ServerRpc.msg.sendMsgResp.sendTime)
}
inline ::int64_t sendMsgResp::_internal_sendtime() const {
  return _impl_.sendtime_;
}
inline void sendMsgResp::_internal_set_sendtime(::int64_t value) {
  ;
  _impl_.sendtime_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace msg
}  // namespace ServerRpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_msg_2eproto_2epb_2eh
