// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conversation.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_conversation_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_conversation_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_conversation_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_conversation_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_conversation_2eproto;
namespace ServerRpc {
namespace conversation {
class batchSetConversationsReq;
struct batchSetConversationsReqDefaultTypeInternal;
extern batchSetConversationsReqDefaultTypeInternal _batchSetConversationsReq_default_instance_;
class batchSetConversationsResp;
struct batchSetConversationsRespDefaultTypeInternal;
extern batchSetConversationsRespDefaultTypeInternal _batchSetConversationsResp_default_instance_;
class conversation;
struct conversationDefaultTypeInternal;
extern conversationDefaultTypeInternal _conversation_default_instance_;
class createGroupChatConversationsReq;
struct createGroupChatConversationsReqDefaultTypeInternal;
extern createGroupChatConversationsReqDefaultTypeInternal _createGroupChatConversationsReq_default_instance_;
class createGroupChatConversationsResp;
struct createGroupChatConversationsRespDefaultTypeInternal;
extern createGroupChatConversationsRespDefaultTypeInternal _createGroupChatConversationsResp_default_instance_;
class createSingleChatConversationsReq;
struct createSingleChatConversationsReqDefaultTypeInternal;
extern createSingleChatConversationsReqDefaultTypeInternal _createSingleChatConversationsReq_default_instance_;
class createSingleChatConversationsResp;
struct createSingleChatConversationsRespDefaultTypeInternal;
extern createSingleChatConversationsRespDefaultTypeInternal _createSingleChatConversationsResp_default_instance_;
class getAllConversationsReq;
struct getAllConversationsReqDefaultTypeInternal;
extern getAllConversationsReqDefaultTypeInternal _getAllConversationsReq_default_instance_;
class getAllConversationsResp;
struct getAllConversationsRespDefaultTypeInternal;
extern getAllConversationsRespDefaultTypeInternal _getAllConversationsResp_default_instance_;
class getConversationIDsReq;
struct getConversationIDsReqDefaultTypeInternal;
extern getConversationIDsReqDefaultTypeInternal _getConversationIDsReq_default_instance_;
class getConversationIDsResp;
struct getConversationIDsRespDefaultTypeInternal;
extern getConversationIDsRespDefaultTypeInternal _getConversationIDsResp_default_instance_;
class getConversationReq;
struct getConversationReqDefaultTypeInternal;
extern getConversationReqDefaultTypeInternal _getConversationReq_default_instance_;
class getConversationResp;
struct getConversationRespDefaultTypeInternal;
extern getConversationRespDefaultTypeInternal _getConversationResp_default_instance_;
class getConversationsByConversationIDReq;
struct getConversationsByConversationIDReqDefaultTypeInternal;
extern getConversationsByConversationIDReqDefaultTypeInternal _getConversationsByConversationIDReq_default_instance_;
class getConversationsByConversationIDResp;
struct getConversationsByConversationIDRespDefaultTypeInternal;
extern getConversationsByConversationIDRespDefaultTypeInternal _getConversationsByConversationIDResp_default_instance_;
class getConversationsReq;
struct getConversationsReqDefaultTypeInternal;
extern getConversationsReqDefaultTypeInternal _getConversationsReq_default_instance_;
class getConversationsResp;
struct getConversationsRespDefaultTypeInternal;
extern getConversationsRespDefaultTypeInternal _getConversationsResp_default_instance_;
class getUserConversationIDsHashReq;
struct getUserConversationIDsHashReqDefaultTypeInternal;
extern getUserConversationIDsHashReqDefaultTypeInternal _getUserConversationIDsHashReq_default_instance_;
class getUserConversationIDsHashResp;
struct getUserConversationIDsHashRespDefaultTypeInternal;
extern getUserConversationIDsHashRespDefaultTypeInternal _getUserConversationIDsHashResp_default_instance_;
class setConversationMaxSeqReq;
struct setConversationMaxSeqReqDefaultTypeInternal;
extern setConversationMaxSeqReqDefaultTypeInternal _setConversationMaxSeqReq_default_instance_;
class setConversationMaxSeqResp;
struct setConversationMaxSeqRespDefaultTypeInternal;
extern setConversationMaxSeqRespDefaultTypeInternal _setConversationMaxSeqResp_default_instance_;
class setConversationReq;
struct setConversationReqDefaultTypeInternal;
extern setConversationReqDefaultTypeInternal _setConversationReq_default_instance_;
class setConversationResp;
struct setConversationRespDefaultTypeInternal;
extern setConversationRespDefaultTypeInternal _setConversationResp_default_instance_;
}  // namespace conversation
}  // namespace ServerRpc
PROTOBUF_NAMESPACE_OPEN
template <>
::ServerRpc::conversation::batchSetConversationsReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::batchSetConversationsReq>(Arena*);
template <>
::ServerRpc::conversation::batchSetConversationsResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::batchSetConversationsResp>(Arena*);
template <>
::ServerRpc::conversation::conversation* Arena::CreateMaybeMessage<::ServerRpc::conversation::conversation>(Arena*);
template <>
::ServerRpc::conversation::createGroupChatConversationsReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::createGroupChatConversationsReq>(Arena*);
template <>
::ServerRpc::conversation::createGroupChatConversationsResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::createGroupChatConversationsResp>(Arena*);
template <>
::ServerRpc::conversation::createSingleChatConversationsReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::createSingleChatConversationsReq>(Arena*);
template <>
::ServerRpc::conversation::createSingleChatConversationsResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::createSingleChatConversationsResp>(Arena*);
template <>
::ServerRpc::conversation::getAllConversationsReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::getAllConversationsReq>(Arena*);
template <>
::ServerRpc::conversation::getAllConversationsResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::getAllConversationsResp>(Arena*);
template <>
::ServerRpc::conversation::getConversationIDsReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::getConversationIDsReq>(Arena*);
template <>
::ServerRpc::conversation::getConversationIDsResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::getConversationIDsResp>(Arena*);
template <>
::ServerRpc::conversation::getConversationReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::getConversationReq>(Arena*);
template <>
::ServerRpc::conversation::getConversationResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::getConversationResp>(Arena*);
template <>
::ServerRpc::conversation::getConversationsByConversationIDReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::getConversationsByConversationIDReq>(Arena*);
template <>
::ServerRpc::conversation::getConversationsByConversationIDResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::getConversationsByConversationIDResp>(Arena*);
template <>
::ServerRpc::conversation::getConversationsReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::getConversationsReq>(Arena*);
template <>
::ServerRpc::conversation::getConversationsResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::getConversationsResp>(Arena*);
template <>
::ServerRpc::conversation::getUserConversationIDsHashReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::getUserConversationIDsHashReq>(Arena*);
template <>
::ServerRpc::conversation::getUserConversationIDsHashResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::getUserConversationIDsHashResp>(Arena*);
template <>
::ServerRpc::conversation::setConversationMaxSeqReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::setConversationMaxSeqReq>(Arena*);
template <>
::ServerRpc::conversation::setConversationMaxSeqResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::setConversationMaxSeqResp>(Arena*);
template <>
::ServerRpc::conversation::setConversationReq* Arena::CreateMaybeMessage<::ServerRpc::conversation::setConversationReq>(Arena*);
template <>
::ServerRpc::conversation::setConversationResp* Arena::CreateMaybeMessage<::ServerRpc::conversation::setConversationResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace ServerRpc {
namespace conversation {

// ===================================================================


// -------------------------------------------------------------------

class conversation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.conversation) */ {
 public:
  inline conversation() : conversation(nullptr) {}
  ~conversation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR conversation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  conversation(const conversation& from);
  conversation(conversation&& from) noexcept
    : conversation() {
    *this = ::std::move(from);
  }

  inline conversation& operator=(const conversation& from) {
    CopyFrom(from);
    return *this;
  }
  inline conversation& operator=(conversation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const conversation& default_instance() {
    return *internal_default_instance();
  }
  static inline const conversation* internal_default_instance() {
    return reinterpret_cast<const conversation*>(
               &_conversation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(conversation& a, conversation& b) {
    a.Swap(&b);
  }
  inline void Swap(conversation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(conversation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  conversation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<conversation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const conversation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const conversation& from) {
    conversation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(conversation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.conversation";
  }
  protected:
  explicit conversation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 1,
    kConversationIdFieldNumber = 2,
    kGroupIdFieldNumber = 4,
    kToUserIdFieldNumber = 5,
    kMaxSeqFieldNumber = 6,
    kMinSeqFieldNumber = 7,
    kConversationTypeFieldNumber = 3,
  };
  // string ownerId = 1;
  void clear_ownerid() ;
  const std::string& ownerid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ownerid(Arg_&& arg, Args_... args);
  std::string* mutable_ownerid();
  PROTOBUF_NODISCARD std::string* release_ownerid();
  void set_allocated_ownerid(std::string* ptr);

  private:
  const std::string& _internal_ownerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerid(
      const std::string& value);
  std::string* _internal_mutable_ownerid();

  public:
  // string conversationId = 2;
  void clear_conversationid() ;
  const std::string& conversationid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_conversationid(Arg_&& arg, Args_... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* ptr);

  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(
      const std::string& value);
  std::string* _internal_mutable_conversationid();

  public:
  // string groupId = 4;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // string toUserId = 5;
  void clear_touserid() ;
  const std::string& touserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_touserid(Arg_&& arg, Args_... args);
  std::string* mutable_touserid();
  PROTOBUF_NODISCARD std::string* release_touserid();
  void set_allocated_touserid(std::string* ptr);

  private:
  const std::string& _internal_touserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_touserid(
      const std::string& value);
  std::string* _internal_mutable_touserid();

  public:
  // uint64 maxSeq = 6;
  void clear_maxseq() ;
  ::uint64_t maxseq() const;
  void set_maxseq(::uint64_t value);

  private:
  ::uint64_t _internal_maxseq() const;
  void _internal_set_maxseq(::uint64_t value);

  public:
  // uint64 minSeq = 7;
  void clear_minseq() ;
  ::uint64_t minseq() const;
  void set_minseq(::uint64_t value);

  private:
  ::uint64_t _internal_minseq() const;
  void _internal_set_minseq(::uint64_t value);

  public:
  // int32 conversationType = 3;
  void clear_conversationtype() ;
  ::int32_t conversationtype() const;
  void set_conversationtype(::int32_t value);

  private:
  ::int32_t _internal_conversationtype() const;
  void _internal_set_conversationtype(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.conversation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr touserid_;
    ::uint64_t maxseq_;
    ::uint64_t minseq_;
    ::int32_t conversationtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class setConversationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.setConversationReq) */ {
 public:
  inline setConversationReq() : setConversationReq(nullptr) {}
  ~setConversationReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR setConversationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  setConversationReq(const setConversationReq& from);
  setConversationReq(setConversationReq&& from) noexcept
    : setConversationReq() {
    *this = ::std::move(from);
  }

  inline setConversationReq& operator=(const setConversationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline setConversationReq& operator=(setConversationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setConversationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const setConversationReq* internal_default_instance() {
    return reinterpret_cast<const setConversationReq*>(
               &_setConversationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(setConversationReq& a, setConversationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(setConversationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setConversationReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setConversationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setConversationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const setConversationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const setConversationReq& from) {
    setConversationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(setConversationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.setConversationReq";
  }
  protected:
  explicit setConversationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationFieldNumber = 1,
  };
  // .ServerRpc.conversation.conversation conversation = 1;
  bool has_conversation() const;
  void clear_conversation() ;
  const ::ServerRpc::conversation::conversation& conversation() const;
  PROTOBUF_NODISCARD ::ServerRpc::conversation::conversation* release_conversation();
  ::ServerRpc::conversation::conversation* mutable_conversation();
  void set_allocated_conversation(::ServerRpc::conversation::conversation* conversation);
  private:
  const ::ServerRpc::conversation::conversation& _internal_conversation() const;
  ::ServerRpc::conversation::conversation* _internal_mutable_conversation();
  public:
  void unsafe_arena_set_allocated_conversation(
      ::ServerRpc::conversation::conversation* conversation);
  ::ServerRpc::conversation::conversation* unsafe_arena_release_conversation();
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.setConversationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ServerRpc::conversation::conversation* conversation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class setConversationResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.setConversationResp) */ {
 public:
  inline setConversationResp() : setConversationResp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR setConversationResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  setConversationResp(const setConversationResp& from);
  setConversationResp(setConversationResp&& from) noexcept
    : setConversationResp() {
    *this = ::std::move(from);
  }

  inline setConversationResp& operator=(const setConversationResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline setConversationResp& operator=(setConversationResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setConversationResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const setConversationResp* internal_default_instance() {
    return reinterpret_cast<const setConversationResp*>(
               &_setConversationResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(setConversationResp& a, setConversationResp& b) {
    a.Swap(&b);
  }
  inline void Swap(setConversationResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setConversationResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setConversationResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setConversationResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const setConversationResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const setConversationResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.setConversationResp";
  }
  protected:
  explicit setConversationResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.setConversationResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getConversationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getConversationReq) */ {
 public:
  inline getConversationReq() : getConversationReq(nullptr) {}
  ~getConversationReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getConversationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getConversationReq(const getConversationReq& from);
  getConversationReq(getConversationReq&& from) noexcept
    : getConversationReq() {
    *this = ::std::move(from);
  }

  inline getConversationReq& operator=(const getConversationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getConversationReq& operator=(getConversationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getConversationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getConversationReq* internal_default_instance() {
    return reinterpret_cast<const getConversationReq*>(
               &_getConversationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(getConversationReq& a, getConversationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getConversationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getConversationReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getConversationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getConversationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getConversationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getConversationReq& from) {
    getConversationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getConversationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getConversationReq";
  }
  protected:
  explicit getConversationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
    kOwnerUserIDFieldNumber = 2,
  };
  // string conversationID = 1;
  void clear_conversationid() ;
  const std::string& conversationid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_conversationid(Arg_&& arg, Args_... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* ptr);

  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(
      const std::string& value);
  std::string* _internal_mutable_conversationid();

  public:
  // string ownerUserID = 2;
  void clear_owneruserid() ;
  const std::string& owneruserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owneruserid(Arg_&& arg, Args_... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* ptr);

  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(
      const std::string& value);
  std::string* _internal_mutable_owneruserid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getConversationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getConversationResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getConversationResp) */ {
 public:
  inline getConversationResp() : getConversationResp(nullptr) {}
  ~getConversationResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getConversationResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getConversationResp(const getConversationResp& from);
  getConversationResp(getConversationResp&& from) noexcept
    : getConversationResp() {
    *this = ::std::move(from);
  }

  inline getConversationResp& operator=(const getConversationResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getConversationResp& operator=(getConversationResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getConversationResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getConversationResp* internal_default_instance() {
    return reinterpret_cast<const getConversationResp*>(
               &_getConversationResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(getConversationResp& a, getConversationResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getConversationResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getConversationResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getConversationResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getConversationResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getConversationResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getConversationResp& from) {
    getConversationResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getConversationResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getConversationResp";
  }
  protected:
  explicit getConversationResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationFieldNumber = 2,
  };
  // .ServerRpc.conversation.conversation conversation = 2;
  bool has_conversation() const;
  void clear_conversation() ;
  const ::ServerRpc::conversation::conversation& conversation() const;
  PROTOBUF_NODISCARD ::ServerRpc::conversation::conversation* release_conversation();
  ::ServerRpc::conversation::conversation* mutable_conversation();
  void set_allocated_conversation(::ServerRpc::conversation::conversation* conversation);
  private:
  const ::ServerRpc::conversation::conversation& _internal_conversation() const;
  ::ServerRpc::conversation::conversation* _internal_mutable_conversation();
  public:
  void unsafe_arena_set_allocated_conversation(
      ::ServerRpc::conversation::conversation* conversation);
  ::ServerRpc::conversation::conversation* unsafe_arena_release_conversation();
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getConversationResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ServerRpc::conversation::conversation* conversation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getConversationsReq) */ {
 public:
  inline getConversationsReq() : getConversationsReq(nullptr) {}
  ~getConversationsReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getConversationsReq(const getConversationsReq& from);
  getConversationsReq(getConversationsReq&& from) noexcept
    : getConversationsReq() {
    *this = ::std::move(from);
  }

  inline getConversationsReq& operator=(const getConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getConversationsReq& operator=(getConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getConversationsReq* internal_default_instance() {
    return reinterpret_cast<const getConversationsReq*>(
               &_getConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(getConversationsReq& a, getConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getConversationsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getConversationsReq& from) {
    getConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getConversationsReq";
  }
  protected:
  explicit getConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 2,
    kOwnerUserIDFieldNumber = 1,
  };
  // repeated string conversationIDs = 2;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;

  public:
  void clear_conversationids() ;
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, std::size_t size);
  void set_conversationids(int index, absl::string_view value);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, std::size_t size);
  void add_conversationids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();

  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_conversationids();

  public:
  // string ownerUserID = 1;
  void clear_owneruserid() ;
  const std::string& owneruserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owneruserid(Arg_&& arg, Args_... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* ptr);

  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(
      const std::string& value);
  std::string* _internal_mutable_owneruserid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getConversationsResp) */ {
 public:
  inline getConversationsResp() : getConversationsResp(nullptr) {}
  ~getConversationsResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getConversationsResp(const getConversationsResp& from);
  getConversationsResp(getConversationsResp&& from) noexcept
    : getConversationsResp() {
    *this = ::std::move(from);
  }

  inline getConversationsResp& operator=(const getConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getConversationsResp& operator=(getConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getConversationsResp* internal_default_instance() {
    return reinterpret_cast<const getConversationsResp*>(
               &_getConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(getConversationsResp& a, getConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getConversationsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getConversationsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getConversationsResp& from) {
    getConversationsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getConversationsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getConversationsResp";
  }
  protected:
  explicit getConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 2,
  };
  // repeated .ServerRpc.conversation.conversation conversations = 2;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;

  public:
  void clear_conversations() ;
  ::ServerRpc::conversation::conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >*
      mutable_conversations();
  private:
  const ::ServerRpc::conversation::conversation& _internal_conversations(int index) const;
  ::ServerRpc::conversation::conversation* _internal_add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>& _internal_conversations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>* _internal_mutable_conversations();
  public:
  const ::ServerRpc::conversation::conversation& conversations(int index) const;
  ::ServerRpc::conversation::conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >&
      conversations() const;
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation > conversations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getAllConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getAllConversationsReq) */ {
 public:
  inline getAllConversationsReq() : getAllConversationsReq(nullptr) {}
  ~getAllConversationsReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getAllConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getAllConversationsReq(const getAllConversationsReq& from);
  getAllConversationsReq(getAllConversationsReq&& from) noexcept
    : getAllConversationsReq() {
    *this = ::std::move(from);
  }

  inline getAllConversationsReq& operator=(const getAllConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getAllConversationsReq& operator=(getAllConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getAllConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getAllConversationsReq* internal_default_instance() {
    return reinterpret_cast<const getAllConversationsReq*>(
               &_getAllConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(getAllConversationsReq& a, getAllConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getAllConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getAllConversationsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getAllConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getAllConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getAllConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getAllConversationsReq& from) {
    getAllConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getAllConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getAllConversationsReq";
  }
  protected:
  explicit getAllConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 1,
  };
  // string ownerUserID = 1;
  void clear_owneruserid() ;
  const std::string& owneruserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owneruserid(Arg_&& arg, Args_... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* ptr);

  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(
      const std::string& value);
  std::string* _internal_mutable_owneruserid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getAllConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getAllConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getAllConversationsResp) */ {
 public:
  inline getAllConversationsResp() : getAllConversationsResp(nullptr) {}
  ~getAllConversationsResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getAllConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getAllConversationsResp(const getAllConversationsResp& from);
  getAllConversationsResp(getAllConversationsResp&& from) noexcept
    : getAllConversationsResp() {
    *this = ::std::move(from);
  }

  inline getAllConversationsResp& operator=(const getAllConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getAllConversationsResp& operator=(getAllConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getAllConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getAllConversationsResp* internal_default_instance() {
    return reinterpret_cast<const getAllConversationsResp*>(
               &_getAllConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(getAllConversationsResp& a, getAllConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getAllConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getAllConversationsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getAllConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getAllConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getAllConversationsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getAllConversationsResp& from) {
    getAllConversationsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getAllConversationsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getAllConversationsResp";
  }
  protected:
  explicit getAllConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 2,
  };
  // repeated .ServerRpc.conversation.conversation conversations = 2;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;

  public:
  void clear_conversations() ;
  ::ServerRpc::conversation::conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >*
      mutable_conversations();
  private:
  const ::ServerRpc::conversation::conversation& _internal_conversations(int index) const;
  ::ServerRpc::conversation::conversation* _internal_add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>& _internal_conversations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>* _internal_mutable_conversations();
  public:
  const ::ServerRpc::conversation::conversation& conversations(int index) const;
  ::ServerRpc::conversation::conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >&
      conversations() const;
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getAllConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation > conversations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class batchSetConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.batchSetConversationsReq) */ {
 public:
  inline batchSetConversationsReq() : batchSetConversationsReq(nullptr) {}
  ~batchSetConversationsReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR batchSetConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  batchSetConversationsReq(const batchSetConversationsReq& from);
  batchSetConversationsReq(batchSetConversationsReq&& from) noexcept
    : batchSetConversationsReq() {
    *this = ::std::move(from);
  }

  inline batchSetConversationsReq& operator=(const batchSetConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline batchSetConversationsReq& operator=(batchSetConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const batchSetConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const batchSetConversationsReq* internal_default_instance() {
    return reinterpret_cast<const batchSetConversationsReq*>(
               &_batchSetConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(batchSetConversationsReq& a, batchSetConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(batchSetConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(batchSetConversationsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  batchSetConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<batchSetConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const batchSetConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const batchSetConversationsReq& from) {
    batchSetConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(batchSetConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.batchSetConversationsReq";
  }
  protected:
  explicit batchSetConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 1,
    kOwnerUserIDFieldNumber = 2,
  };
  // repeated .ServerRpc.conversation.conversation conversations = 1;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;

  public:
  void clear_conversations() ;
  ::ServerRpc::conversation::conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >*
      mutable_conversations();
  private:
  const ::ServerRpc::conversation::conversation& _internal_conversations(int index) const;
  ::ServerRpc::conversation::conversation* _internal_add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>& _internal_conversations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>* _internal_mutable_conversations();
  public:
  const ::ServerRpc::conversation::conversation& conversations(int index) const;
  ::ServerRpc::conversation::conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >&
      conversations() const;
  // string ownerUserID = 2;
  void clear_owneruserid() ;
  const std::string& owneruserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owneruserid(Arg_&& arg, Args_... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* ptr);

  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(
      const std::string& value);
  std::string* _internal_mutable_owneruserid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.batchSetConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation > conversations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class batchSetConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.batchSetConversationsResp) */ {
 public:
  inline batchSetConversationsResp() : batchSetConversationsResp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR batchSetConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  batchSetConversationsResp(const batchSetConversationsResp& from);
  batchSetConversationsResp(batchSetConversationsResp&& from) noexcept
    : batchSetConversationsResp() {
    *this = ::std::move(from);
  }

  inline batchSetConversationsResp& operator=(const batchSetConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline batchSetConversationsResp& operator=(batchSetConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const batchSetConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const batchSetConversationsResp* internal_default_instance() {
    return reinterpret_cast<const batchSetConversationsResp*>(
               &_batchSetConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(batchSetConversationsResp& a, batchSetConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(batchSetConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(batchSetConversationsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  batchSetConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<batchSetConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const batchSetConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const batchSetConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.batchSetConversationsResp";
  }
  protected:
  explicit batchSetConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.batchSetConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class createSingleChatConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.createSingleChatConversationsReq) */ {
 public:
  inline createSingleChatConversationsReq() : createSingleChatConversationsReq(nullptr) {}
  ~createSingleChatConversationsReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR createSingleChatConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createSingleChatConversationsReq(const createSingleChatConversationsReq& from);
  createSingleChatConversationsReq(createSingleChatConversationsReq&& from) noexcept
    : createSingleChatConversationsReq() {
    *this = ::std::move(from);
  }

  inline createSingleChatConversationsReq& operator=(const createSingleChatConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline createSingleChatConversationsReq& operator=(createSingleChatConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createSingleChatConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const createSingleChatConversationsReq* internal_default_instance() {
    return reinterpret_cast<const createSingleChatConversationsReq*>(
               &_createSingleChatConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(createSingleChatConversationsReq& a, createSingleChatConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(createSingleChatConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createSingleChatConversationsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createSingleChatConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createSingleChatConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const createSingleChatConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const createSingleChatConversationsReq& from) {
    createSingleChatConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(createSingleChatConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.createSingleChatConversationsReq";
  }
  protected:
  explicit createSingleChatConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecvIDFieldNumber = 1,
    kSendIDFieldNumber = 2,
  };
  // string recvID = 1;
  void clear_recvid() ;
  const std::string& recvid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recvid(Arg_&& arg, Args_... args);
  std::string* mutable_recvid();
  PROTOBUF_NODISCARD std::string* release_recvid();
  void set_allocated_recvid(std::string* ptr);

  private:
  const std::string& _internal_recvid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recvid(
      const std::string& value);
  std::string* _internal_mutable_recvid();

  public:
  // string sendID = 2;
  void clear_sendid() ;
  const std::string& sendid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sendid(Arg_&& arg, Args_... args);
  std::string* mutable_sendid();
  PROTOBUF_NODISCARD std::string* release_sendid();
  void set_allocated_sendid(std::string* ptr);

  private:
  const std::string& _internal_sendid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendid(
      const std::string& value);
  std::string* _internal_mutable_sendid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.createSingleChatConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recvid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class createSingleChatConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.createSingleChatConversationsResp) */ {
 public:
  inline createSingleChatConversationsResp() : createSingleChatConversationsResp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR createSingleChatConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createSingleChatConversationsResp(const createSingleChatConversationsResp& from);
  createSingleChatConversationsResp(createSingleChatConversationsResp&& from) noexcept
    : createSingleChatConversationsResp() {
    *this = ::std::move(from);
  }

  inline createSingleChatConversationsResp& operator=(const createSingleChatConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline createSingleChatConversationsResp& operator=(createSingleChatConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createSingleChatConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const createSingleChatConversationsResp* internal_default_instance() {
    return reinterpret_cast<const createSingleChatConversationsResp*>(
               &_createSingleChatConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(createSingleChatConversationsResp& a, createSingleChatConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(createSingleChatConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createSingleChatConversationsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createSingleChatConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createSingleChatConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const createSingleChatConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const createSingleChatConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.createSingleChatConversationsResp";
  }
  protected:
  explicit createSingleChatConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.createSingleChatConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class createGroupChatConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.createGroupChatConversationsReq) */ {
 public:
  inline createGroupChatConversationsReq() : createGroupChatConversationsReq(nullptr) {}
  ~createGroupChatConversationsReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR createGroupChatConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createGroupChatConversationsReq(const createGroupChatConversationsReq& from);
  createGroupChatConversationsReq(createGroupChatConversationsReq&& from) noexcept
    : createGroupChatConversationsReq() {
    *this = ::std::move(from);
  }

  inline createGroupChatConversationsReq& operator=(const createGroupChatConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline createGroupChatConversationsReq& operator=(createGroupChatConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createGroupChatConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const createGroupChatConversationsReq* internal_default_instance() {
    return reinterpret_cast<const createGroupChatConversationsReq*>(
               &_createGroupChatConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(createGroupChatConversationsReq& a, createGroupChatConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(createGroupChatConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createGroupChatConversationsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createGroupChatConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createGroupChatConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const createGroupChatConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const createGroupChatConversationsReq& from) {
    createGroupChatConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(createGroupChatConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.createGroupChatConversationsReq";
  }
  protected:
  explicit createGroupChatConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDsFieldNumber = 1,
    kGroupIDFieldNumber = 2,
  };
  // repeated string userIDs = 1;
  int userids_size() const;
  private:
  int _internal_userids_size() const;

  public:
  void clear_userids() ;
  const std::string& userids(int index) const;
  std::string* mutable_userids(int index);
  void set_userids(int index, const std::string& value);
  void set_userids(int index, std::string&& value);
  void set_userids(int index, const char* value);
  void set_userids(int index, const char* value, std::size_t size);
  void set_userids(int index, absl::string_view value);
  std::string* add_userids();
  void add_userids(const std::string& value);
  void add_userids(std::string&& value);
  void add_userids(const char* value);
  void add_userids(const char* value, std::size_t size);
  void add_userids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userids();

  private:
  const std::string& _internal_userids(int index) const;
  std::string* _internal_add_userids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_userids();

  public:
  // string groupID = 2;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.createGroupChatConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class createGroupChatConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.createGroupChatConversationsResp) */ {
 public:
  inline createGroupChatConversationsResp() : createGroupChatConversationsResp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR createGroupChatConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createGroupChatConversationsResp(const createGroupChatConversationsResp& from);
  createGroupChatConversationsResp(createGroupChatConversationsResp&& from) noexcept
    : createGroupChatConversationsResp() {
    *this = ::std::move(from);
  }

  inline createGroupChatConversationsResp& operator=(const createGroupChatConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline createGroupChatConversationsResp& operator=(createGroupChatConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createGroupChatConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const createGroupChatConversationsResp* internal_default_instance() {
    return reinterpret_cast<const createGroupChatConversationsResp*>(
               &_createGroupChatConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(createGroupChatConversationsResp& a, createGroupChatConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(createGroupChatConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createGroupChatConversationsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createGroupChatConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createGroupChatConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const createGroupChatConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const createGroupChatConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.createGroupChatConversationsResp";
  }
  protected:
  explicit createGroupChatConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.createGroupChatConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class setConversationMaxSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.setConversationMaxSeqReq) */ {
 public:
  inline setConversationMaxSeqReq() : setConversationMaxSeqReq(nullptr) {}
  ~setConversationMaxSeqReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR setConversationMaxSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  setConversationMaxSeqReq(const setConversationMaxSeqReq& from);
  setConversationMaxSeqReq(setConversationMaxSeqReq&& from) noexcept
    : setConversationMaxSeqReq() {
    *this = ::std::move(from);
  }

  inline setConversationMaxSeqReq& operator=(const setConversationMaxSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline setConversationMaxSeqReq& operator=(setConversationMaxSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setConversationMaxSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const setConversationMaxSeqReq* internal_default_instance() {
    return reinterpret_cast<const setConversationMaxSeqReq*>(
               &_setConversationMaxSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(setConversationMaxSeqReq& a, setConversationMaxSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(setConversationMaxSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setConversationMaxSeqReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setConversationMaxSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setConversationMaxSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const setConversationMaxSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const setConversationMaxSeqReq& from) {
    setConversationMaxSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(setConversationMaxSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.setConversationMaxSeqReq";
  }
  protected:
  explicit setConversationMaxSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 2,
    kConversationIDFieldNumber = 1,
    kMaxSeqFieldNumber = 3,
  };
  // repeated string ownerUserID = 2;
  int owneruserid_size() const;
  private:
  int _internal_owneruserid_size() const;

  public:
  void clear_owneruserid() ;
  const std::string& owneruserid(int index) const;
  std::string* mutable_owneruserid(int index);
  void set_owneruserid(int index, const std::string& value);
  void set_owneruserid(int index, std::string&& value);
  void set_owneruserid(int index, const char* value);
  void set_owneruserid(int index, const char* value, std::size_t size);
  void set_owneruserid(int index, absl::string_view value);
  std::string* add_owneruserid();
  void add_owneruserid(const std::string& value);
  void add_owneruserid(std::string&& value);
  void add_owneruserid(const char* value);
  void add_owneruserid(const char* value, std::size_t size);
  void add_owneruserid(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& owneruserid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_owneruserid();

  private:
  const std::string& _internal_owneruserid(int index) const;
  std::string* _internal_add_owneruserid();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_owneruserid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_owneruserid();

  public:
  // string conversationID = 1;
  void clear_conversationid() ;
  const std::string& conversationid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_conversationid(Arg_&& arg, Args_... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* ptr);

  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(
      const std::string& value);
  std::string* _internal_mutable_conversationid();

  public:
  // int64 maxSeq = 3;
  void clear_maxseq() ;
  ::int64_t maxseq() const;
  void set_maxseq(::int64_t value);

  private:
  ::int64_t _internal_maxseq() const;
  void _internal_set_maxseq(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.setConversationMaxSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> owneruserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::int64_t maxseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class setConversationMaxSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.setConversationMaxSeqResp) */ {
 public:
  inline setConversationMaxSeqResp() : setConversationMaxSeqResp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR setConversationMaxSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  setConversationMaxSeqResp(const setConversationMaxSeqResp& from);
  setConversationMaxSeqResp(setConversationMaxSeqResp&& from) noexcept
    : setConversationMaxSeqResp() {
    *this = ::std::move(from);
  }

  inline setConversationMaxSeqResp& operator=(const setConversationMaxSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline setConversationMaxSeqResp& operator=(setConversationMaxSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setConversationMaxSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const setConversationMaxSeqResp* internal_default_instance() {
    return reinterpret_cast<const setConversationMaxSeqResp*>(
               &_setConversationMaxSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(setConversationMaxSeqResp& a, setConversationMaxSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(setConversationMaxSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setConversationMaxSeqResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setConversationMaxSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setConversationMaxSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const setConversationMaxSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const setConversationMaxSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.setConversationMaxSeqResp";
  }
  protected:
  explicit setConversationMaxSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.setConversationMaxSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getConversationIDsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getConversationIDsReq) */ {
 public:
  inline getConversationIDsReq() : getConversationIDsReq(nullptr) {}
  ~getConversationIDsReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getConversationIDsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getConversationIDsReq(const getConversationIDsReq& from);
  getConversationIDsReq(getConversationIDsReq&& from) noexcept
    : getConversationIDsReq() {
    *this = ::std::move(from);
  }

  inline getConversationIDsReq& operator=(const getConversationIDsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getConversationIDsReq& operator=(getConversationIDsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getConversationIDsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getConversationIDsReq* internal_default_instance() {
    return reinterpret_cast<const getConversationIDsReq*>(
               &_getConversationIDsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(getConversationIDsReq& a, getConversationIDsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getConversationIDsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getConversationIDsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getConversationIDsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getConversationIDsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getConversationIDsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getConversationIDsReq& from) {
    getConversationIDsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getConversationIDsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getConversationIDsReq";
  }
  protected:
  explicit getConversationIDsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid() ;
  const std::string& userid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userid(Arg_&& arg, Args_... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* ptr);

  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(
      const std::string& value);
  std::string* _internal_mutable_userid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getConversationIDsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getConversationIDsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getConversationIDsResp) */ {
 public:
  inline getConversationIDsResp() : getConversationIDsResp(nullptr) {}
  ~getConversationIDsResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getConversationIDsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getConversationIDsResp(const getConversationIDsResp& from);
  getConversationIDsResp(getConversationIDsResp&& from) noexcept
    : getConversationIDsResp() {
    *this = ::std::move(from);
  }

  inline getConversationIDsResp& operator=(const getConversationIDsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getConversationIDsResp& operator=(getConversationIDsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getConversationIDsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getConversationIDsResp* internal_default_instance() {
    return reinterpret_cast<const getConversationIDsResp*>(
               &_getConversationIDsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(getConversationIDsResp& a, getConversationIDsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getConversationIDsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getConversationIDsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getConversationIDsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getConversationIDsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getConversationIDsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getConversationIDsResp& from) {
    getConversationIDsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getConversationIDsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getConversationIDsResp";
  }
  protected:
  explicit getConversationIDsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;

  public:
  void clear_conversationids() ;
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, std::size_t size);
  void set_conversationids(int index, absl::string_view value);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, std::size_t size);
  void add_conversationids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();

  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_conversationids();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getConversationIDsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getUserConversationIDsHashReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getUserConversationIDsHashReq) */ {
 public:
  inline getUserConversationIDsHashReq() : getUserConversationIDsHashReq(nullptr) {}
  ~getUserConversationIDsHashReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getUserConversationIDsHashReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getUserConversationIDsHashReq(const getUserConversationIDsHashReq& from);
  getUserConversationIDsHashReq(getUserConversationIDsHashReq&& from) noexcept
    : getUserConversationIDsHashReq() {
    *this = ::std::move(from);
  }

  inline getUserConversationIDsHashReq& operator=(const getUserConversationIDsHashReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getUserConversationIDsHashReq& operator=(getUserConversationIDsHashReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getUserConversationIDsHashReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getUserConversationIDsHashReq* internal_default_instance() {
    return reinterpret_cast<const getUserConversationIDsHashReq*>(
               &_getUserConversationIDsHashReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(getUserConversationIDsHashReq& a, getUserConversationIDsHashReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getUserConversationIDsHashReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getUserConversationIDsHashReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getUserConversationIDsHashReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getUserConversationIDsHashReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getUserConversationIDsHashReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getUserConversationIDsHashReq& from) {
    getUserConversationIDsHashReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getUserConversationIDsHashReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getUserConversationIDsHashReq";
  }
  protected:
  explicit getUserConversationIDsHashReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 1,
  };
  // string ownerUserID = 1;
  void clear_owneruserid() ;
  const std::string& owneruserid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owneruserid(Arg_&& arg, Args_... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* ptr);

  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(
      const std::string& value);
  std::string* _internal_mutable_owneruserid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getUserConversationIDsHashReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getUserConversationIDsHashResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getUserConversationIDsHashResp) */ {
 public:
  inline getUserConversationIDsHashResp() : getUserConversationIDsHashResp(nullptr) {}
  ~getUserConversationIDsHashResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getUserConversationIDsHashResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getUserConversationIDsHashResp(const getUserConversationIDsHashResp& from);
  getUserConversationIDsHashResp(getUserConversationIDsHashResp&& from) noexcept
    : getUserConversationIDsHashResp() {
    *this = ::std::move(from);
  }

  inline getUserConversationIDsHashResp& operator=(const getUserConversationIDsHashResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getUserConversationIDsHashResp& operator=(getUserConversationIDsHashResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getUserConversationIDsHashResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getUserConversationIDsHashResp* internal_default_instance() {
    return reinterpret_cast<const getUserConversationIDsHashResp*>(
               &_getUserConversationIDsHashResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(getUserConversationIDsHashResp& a, getUserConversationIDsHashResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getUserConversationIDsHashResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getUserConversationIDsHashResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getUserConversationIDsHashResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getUserConversationIDsHashResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getUserConversationIDsHashResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getUserConversationIDsHashResp& from) {
    getUserConversationIDsHashResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getUserConversationIDsHashResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getUserConversationIDsHashResp";
  }
  protected:
  explicit getUserConversationIDsHashResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // uint64 hash = 1;
  void clear_hash() ;
  ::uint64_t hash() const;
  void set_hash(::uint64_t value);

  private:
  ::uint64_t _internal_hash() const;
  void _internal_set_hash(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getUserConversationIDsHashResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getConversationsByConversationIDReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getConversationsByConversationIDReq) */ {
 public:
  inline getConversationsByConversationIDReq() : getConversationsByConversationIDReq(nullptr) {}
  ~getConversationsByConversationIDReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getConversationsByConversationIDReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getConversationsByConversationIDReq(const getConversationsByConversationIDReq& from);
  getConversationsByConversationIDReq(getConversationsByConversationIDReq&& from) noexcept
    : getConversationsByConversationIDReq() {
    *this = ::std::move(from);
  }

  inline getConversationsByConversationIDReq& operator=(const getConversationsByConversationIDReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getConversationsByConversationIDReq& operator=(getConversationsByConversationIDReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getConversationsByConversationIDReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getConversationsByConversationIDReq* internal_default_instance() {
    return reinterpret_cast<const getConversationsByConversationIDReq*>(
               &_getConversationsByConversationIDReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(getConversationsByConversationIDReq& a, getConversationsByConversationIDReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getConversationsByConversationIDReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getConversationsByConversationIDReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getConversationsByConversationIDReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getConversationsByConversationIDReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getConversationsByConversationIDReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getConversationsByConversationIDReq& from) {
    getConversationsByConversationIDReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getConversationsByConversationIDReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getConversationsByConversationIDReq";
  }
  protected:
  explicit getConversationsByConversationIDReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;

  public:
  void clear_conversationids() ;
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, std::size_t size);
  void set_conversationids(int index, absl::string_view value);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, std::size_t size);
  void add_conversationids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();

  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_conversationids();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getConversationsByConversationIDReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};// -------------------------------------------------------------------

class getConversationsByConversationIDResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.conversation.getConversationsByConversationIDResp) */ {
 public:
  inline getConversationsByConversationIDResp() : getConversationsByConversationIDResp(nullptr) {}
  ~getConversationsByConversationIDResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getConversationsByConversationIDResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getConversationsByConversationIDResp(const getConversationsByConversationIDResp& from);
  getConversationsByConversationIDResp(getConversationsByConversationIDResp&& from) noexcept
    : getConversationsByConversationIDResp() {
    *this = ::std::move(from);
  }

  inline getConversationsByConversationIDResp& operator=(const getConversationsByConversationIDResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getConversationsByConversationIDResp& operator=(getConversationsByConversationIDResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getConversationsByConversationIDResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getConversationsByConversationIDResp* internal_default_instance() {
    return reinterpret_cast<const getConversationsByConversationIDResp*>(
               &_getConversationsByConversationIDResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(getConversationsByConversationIDResp& a, getConversationsByConversationIDResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getConversationsByConversationIDResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getConversationsByConversationIDResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getConversationsByConversationIDResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getConversationsByConversationIDResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getConversationsByConversationIDResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getConversationsByConversationIDResp& from) {
    getConversationsByConversationIDResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getConversationsByConversationIDResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.conversation.getConversationsByConversationIDResp";
  }
  protected:
  explicit getConversationsByConversationIDResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 1,
  };
  // repeated .ServerRpc.conversation.conversation conversations = 1;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;

  public:
  void clear_conversations() ;
  ::ServerRpc::conversation::conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >*
      mutable_conversations();
  private:
  const ::ServerRpc::conversation::conversation& _internal_conversations(int index) const;
  ::ServerRpc::conversation::conversation* _internal_add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>& _internal_conversations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>* _internal_mutable_conversations();
  public:
  const ::ServerRpc::conversation::conversation& conversations(int index) const;
  ::ServerRpc::conversation::conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >&
      conversations() const;
  // @@protoc_insertion_point(class_scope:ServerRpc.conversation.getConversationsByConversationIDResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation > conversations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// conversation

// string ownerId = 1;
inline void conversation::clear_ownerid() {
  _impl_.ownerid_.ClearToEmpty();
}
inline const std::string& conversation::ownerid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.conversation.ownerId)
  return _internal_ownerid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void conversation::set_ownerid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ownerid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.conversation.ownerId)
}
inline std::string* conversation::mutable_ownerid() {
  std::string* _s = _internal_mutable_ownerid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.conversation.ownerId)
  return _s;
}
inline const std::string& conversation::_internal_ownerid() const {
  return _impl_.ownerid_.Get();
}
inline void conversation::_internal_set_ownerid(const std::string& value) {
  ;


  _impl_.ownerid_.Set(value, GetArenaForAllocation());
}
inline std::string* conversation::_internal_mutable_ownerid() {
  ;
  return _impl_.ownerid_.Mutable( GetArenaForAllocation());
}
inline std::string* conversation::release_ownerid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.conversation.ownerId)
  return _impl_.ownerid_.Release();
}
inline void conversation::set_allocated_ownerid(std::string* value) {
  _impl_.ownerid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ownerid_.IsDefault()) {
          _impl_.ownerid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.conversation.ownerId)
}

// string conversationId = 2;
inline void conversation::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& conversation::conversationid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.conversation.conversationId)
  return _internal_conversationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void conversation::set_conversationid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.conversationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.conversation.conversationId)
}
inline std::string* conversation::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.conversation.conversationId)
  return _s;
}
inline const std::string& conversation::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void conversation::_internal_set_conversationid(const std::string& value) {
  ;


  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* conversation::_internal_mutable_conversationid() {
  ;
  return _impl_.conversationid_.Mutable( GetArenaForAllocation());
}
inline std::string* conversation::release_conversationid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.conversation.conversationId)
  return _impl_.conversationid_.Release();
}
inline void conversation::set_allocated_conversationid(std::string* value) {
  _impl_.conversationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.conversationid_.IsDefault()) {
          _impl_.conversationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.conversation.conversationId)
}

// int32 conversationType = 3;
inline void conversation::clear_conversationtype() {
  _impl_.conversationtype_ = 0;
}
inline ::int32_t conversation::conversationtype() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.conversation.conversationType)
  return _internal_conversationtype();
}
inline void conversation::set_conversationtype(::int32_t value) {
  _internal_set_conversationtype(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.conversation.conversationType)
}
inline ::int32_t conversation::_internal_conversationtype() const {
  return _impl_.conversationtype_;
}
inline void conversation::_internal_set_conversationtype(::int32_t value) {
  ;
  _impl_.conversationtype_ = value;
}

// string groupId = 4;
inline void conversation::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& conversation::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.conversation.groupId)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void conversation::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.conversation.groupId)
}
inline std::string* conversation::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.conversation.groupId)
  return _s;
}
inline const std::string& conversation::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void conversation::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* conversation::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* conversation::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.conversation.groupId)
  return _impl_.groupid_.Release();
}
inline void conversation::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.conversation.groupId)
}

// string toUserId = 5;
inline void conversation::clear_touserid() {
  _impl_.touserid_.ClearToEmpty();
}
inline const std::string& conversation::touserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.conversation.toUserId)
  return _internal_touserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void conversation::set_touserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.touserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.conversation.toUserId)
}
inline std::string* conversation::mutable_touserid() {
  std::string* _s = _internal_mutable_touserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.conversation.toUserId)
  return _s;
}
inline const std::string& conversation::_internal_touserid() const {
  return _impl_.touserid_.Get();
}
inline void conversation::_internal_set_touserid(const std::string& value) {
  ;


  _impl_.touserid_.Set(value, GetArenaForAllocation());
}
inline std::string* conversation::_internal_mutable_touserid() {
  ;
  return _impl_.touserid_.Mutable( GetArenaForAllocation());
}
inline std::string* conversation::release_touserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.conversation.toUserId)
  return _impl_.touserid_.Release();
}
inline void conversation::set_allocated_touserid(std::string* value) {
  _impl_.touserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.touserid_.IsDefault()) {
          _impl_.touserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.conversation.toUserId)
}

// uint64 maxSeq = 6;
inline void conversation::clear_maxseq() {
  _impl_.maxseq_ = ::uint64_t{0u};
}
inline ::uint64_t conversation::maxseq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.conversation.maxSeq)
  return _internal_maxseq();
}
inline void conversation::set_maxseq(::uint64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.conversation.maxSeq)
}
inline ::uint64_t conversation::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline void conversation::_internal_set_maxseq(::uint64_t value) {
  ;
  _impl_.maxseq_ = value;
}

// uint64 minSeq = 7;
inline void conversation::clear_minseq() {
  _impl_.minseq_ = ::uint64_t{0u};
}
inline ::uint64_t conversation::minseq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.conversation.minSeq)
  return _internal_minseq();
}
inline void conversation::set_minseq(::uint64_t value) {
  _internal_set_minseq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.conversation.minSeq)
}
inline ::uint64_t conversation::_internal_minseq() const {
  return _impl_.minseq_;
}
inline void conversation::_internal_set_minseq(::uint64_t value) {
  ;
  _impl_.minseq_ = value;
}

// -------------------------------------------------------------------

// setConversationReq

// .ServerRpc.conversation.conversation conversation = 1;
inline bool setConversationReq::has_conversation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conversation_ != nullptr);
  return value;
}
inline void setConversationReq::clear_conversation() {
  if (_impl_.conversation_ != nullptr) _impl_.conversation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ServerRpc::conversation::conversation& setConversationReq::_internal_conversation() const {
  const ::ServerRpc::conversation::conversation* p = _impl_.conversation_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerRpc::conversation::conversation&>(
      ::ServerRpc::conversation::_conversation_default_instance_);
}
inline const ::ServerRpc::conversation::conversation& setConversationReq::conversation() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.setConversationReq.conversation)
  return _internal_conversation();
}
inline void setConversationReq::unsafe_arena_set_allocated_conversation(
    ::ServerRpc::conversation::conversation* conversation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conversation_);
  }
  _impl_.conversation_ = conversation;
  if (conversation) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerRpc.conversation.setConversationReq.conversation)
}
inline ::ServerRpc::conversation::conversation* setConversationReq::release_conversation() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::conversation::conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerRpc::conversation::conversation* setConversationReq::unsafe_arena_release_conversation() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.setConversationReq.conversation)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::conversation::conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
  return temp;
}
inline ::ServerRpc::conversation::conversation* setConversationReq::_internal_mutable_conversation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.conversation_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerRpc::conversation::conversation>(GetArenaForAllocation());
    _impl_.conversation_ = p;
  }
  return _impl_.conversation_;
}
inline ::ServerRpc::conversation::conversation* setConversationReq::mutable_conversation() {
  ::ServerRpc::conversation::conversation* _msg = _internal_mutable_conversation();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.setConversationReq.conversation)
  return _msg;
}
inline void setConversationReq::set_allocated_conversation(::ServerRpc::conversation::conversation* conversation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conversation_;
  }
  if (conversation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conversation);
    if (message_arena != submessage_arena) {
      conversation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conversation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.conversation_ = conversation;
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.setConversationReq.conversation)
}

// -------------------------------------------------------------------

// setConversationResp

// -------------------------------------------------------------------

// getConversationReq

// string conversationID = 1;
inline void getConversationReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& getConversationReq::conversationid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationReq.conversationID)
  return _internal_conversationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getConversationReq::set_conversationid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.conversationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationReq.conversationID)
}
inline std::string* getConversationReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationReq.conversationID)
  return _s;
}
inline const std::string& getConversationReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void getConversationReq::_internal_set_conversationid(const std::string& value) {
  ;


  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* getConversationReq::_internal_mutable_conversationid() {
  ;
  return _impl_.conversationid_.Mutable( GetArenaForAllocation());
}
inline std::string* getConversationReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.getConversationReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void getConversationReq::set_allocated_conversationid(std::string* value) {
  _impl_.conversationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.conversationid_.IsDefault()) {
          _impl_.conversationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.getConversationReq.conversationID)
}

// string ownerUserID = 2;
inline void getConversationReq::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& getConversationReq::owneruserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationReq.ownerUserID)
  return _internal_owneruserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getConversationReq::set_owneruserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.owneruserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationReq.ownerUserID)
}
inline std::string* getConversationReq::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationReq.ownerUserID)
  return _s;
}
inline const std::string& getConversationReq::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void getConversationReq::_internal_set_owneruserid(const std::string& value) {
  ;


  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* getConversationReq::_internal_mutable_owneruserid() {
  ;
  return _impl_.owneruserid_.Mutable( GetArenaForAllocation());
}
inline std::string* getConversationReq::release_owneruserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.getConversationReq.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void getConversationReq::set_allocated_owneruserid(std::string* value) {
  _impl_.owneruserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owneruserid_.IsDefault()) {
          _impl_.owneruserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.getConversationReq.ownerUserID)
}

// -------------------------------------------------------------------

// getConversationResp

// .ServerRpc.conversation.conversation conversation = 2;
inline bool getConversationResp::has_conversation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conversation_ != nullptr);
  return value;
}
inline void getConversationResp::clear_conversation() {
  if (_impl_.conversation_ != nullptr) _impl_.conversation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ServerRpc::conversation::conversation& getConversationResp::_internal_conversation() const {
  const ::ServerRpc::conversation::conversation* p = _impl_.conversation_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerRpc::conversation::conversation&>(
      ::ServerRpc::conversation::_conversation_default_instance_);
}
inline const ::ServerRpc::conversation::conversation& getConversationResp::conversation() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationResp.conversation)
  return _internal_conversation();
}
inline void getConversationResp::unsafe_arena_set_allocated_conversation(
    ::ServerRpc::conversation::conversation* conversation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conversation_);
  }
  _impl_.conversation_ = conversation;
  if (conversation) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerRpc.conversation.getConversationResp.conversation)
}
inline ::ServerRpc::conversation::conversation* getConversationResp::release_conversation() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::conversation::conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerRpc::conversation::conversation* getConversationResp::unsafe_arena_release_conversation() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.getConversationResp.conversation)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::conversation::conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
  return temp;
}
inline ::ServerRpc::conversation::conversation* getConversationResp::_internal_mutable_conversation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.conversation_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerRpc::conversation::conversation>(GetArenaForAllocation());
    _impl_.conversation_ = p;
  }
  return _impl_.conversation_;
}
inline ::ServerRpc::conversation::conversation* getConversationResp::mutable_conversation() {
  ::ServerRpc::conversation::conversation* _msg = _internal_mutable_conversation();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationResp.conversation)
  return _msg;
}
inline void getConversationResp::set_allocated_conversation(::ServerRpc::conversation::conversation* conversation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conversation_;
  }
  if (conversation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conversation);
    if (message_arena != submessage_arena) {
      conversation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conversation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.conversation_ = conversation;
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.getConversationResp.conversation)
}

// -------------------------------------------------------------------

// getConversationsReq

// string ownerUserID = 1;
inline void getConversationsReq::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& getConversationsReq::owneruserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationsReq.ownerUserID)
  return _internal_owneruserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getConversationsReq::set_owneruserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.owneruserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationsReq.ownerUserID)
}
inline std::string* getConversationsReq::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationsReq.ownerUserID)
  return _s;
}
inline const std::string& getConversationsReq::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void getConversationsReq::_internal_set_owneruserid(const std::string& value) {
  ;


  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* getConversationsReq::_internal_mutable_owneruserid() {
  ;
  return _impl_.owneruserid_.Mutable( GetArenaForAllocation());
}
inline std::string* getConversationsReq::release_owneruserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.getConversationsReq.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void getConversationsReq::set_allocated_owneruserid(std::string* value) {
  _impl_.owneruserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owneruserid_.IsDefault()) {
          _impl_.owneruserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.getConversationsReq.ownerUserID)
}

// repeated string conversationIDs = 2;
inline int getConversationsReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int getConversationsReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void getConversationsReq::clear_conversationids() {
  _internal_mutable_conversationids()->Clear();
}
inline std::string* getConversationsReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:ServerRpc.conversation.getConversationsReq.conversationIDs)
  return _s;
}
inline const std::string& getConversationsReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationsReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* getConversationsReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationsReq.conversationIDs)
  return _internal_mutable_conversationids()->Mutable(index);
}
inline void getConversationsReq::set_conversationids(int index, const std::string& value) {
  _internal_mutable_conversationids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline void getConversationsReq::set_conversationids(int index, std::string&& value) {
  _internal_mutable_conversationids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline void getConversationsReq::set_conversationids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_conversationids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline void getConversationsReq::set_conversationids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_conversationids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline void getConversationsReq::set_conversationids(int index, absl::string_view value) {
  _internal_mutable_conversationids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline void getConversationsReq::add_conversationids(const std::string& value) {
  _internal_mutable_conversationids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline void getConversationsReq::add_conversationids(std::string&& value) {
  _internal_mutable_conversationids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline void getConversationsReq::add_conversationids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_conversationids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline void getConversationsReq::add_conversationids(const char* value, std::size_t size) {
  _internal_mutable_conversationids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline void getConversationsReq::add_conversationids(absl::string_view value) {
  _internal_mutable_conversationids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ServerRpc.conversation.getConversationsReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
getConversationsReq::conversationids() const {
  // @@protoc_insertion_point(field_list:ServerRpc.conversation.getConversationsReq.conversationIDs)
  return _internal_conversationids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* getConversationsReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.conversation.getConversationsReq.conversationIDs)
  return _internal_mutable_conversationids();
}
inline const std::string& getConversationsReq::_internal_conversationids(int index) const {
  return _internal_conversationids().Get(index);
}
inline std::string* getConversationsReq::_internal_add_conversationids() {
  return _internal_mutable_conversationids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
getConversationsReq::_internal_conversationids() const {
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
getConversationsReq::_internal_mutable_conversationids() {
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// getConversationsResp

// repeated .ServerRpc.conversation.conversation conversations = 2;
inline int getConversationsResp::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int getConversationsResp::conversations_size() const {
  return _internal_conversations_size();
}
inline void getConversationsResp::clear_conversations() {
  _internal_mutable_conversations()->Clear();
}
inline ::ServerRpc::conversation::conversation* getConversationsResp::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationsResp.conversations)
  return _internal_mutable_conversations()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >*
getConversationsResp::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.conversation.getConversationsResp.conversations)
  return _internal_mutable_conversations();
}
inline const ::ServerRpc::conversation::conversation& getConversationsResp::_internal_conversations(int index) const {
  return _internal_conversations().Get(index);
}
inline const ::ServerRpc::conversation::conversation& getConversationsResp::conversations(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationsResp.conversations)
  return _internal_conversations(index);
}
inline ::ServerRpc::conversation::conversation* getConversationsResp::_internal_add_conversations() {
  return _internal_mutable_conversations()->Add();
}
inline ::ServerRpc::conversation::conversation* getConversationsResp::add_conversations() {
  ::ServerRpc::conversation::conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.getConversationsResp.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >&
getConversationsResp::conversations() const {
  // @@protoc_insertion_point(field_list:ServerRpc.conversation.getConversationsResp.conversations)
  return _internal_conversations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>&
getConversationsResp::_internal_conversations() const {
  return _impl_.conversations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>*
getConversationsResp::_internal_mutable_conversations() {
  return &_impl_.conversations_;
}

// -------------------------------------------------------------------

// getAllConversationsReq

// string ownerUserID = 1;
inline void getAllConversationsReq::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& getAllConversationsReq::owneruserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getAllConversationsReq.ownerUserID)
  return _internal_owneruserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getAllConversationsReq::set_owneruserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.owneruserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getAllConversationsReq.ownerUserID)
}
inline std::string* getAllConversationsReq::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getAllConversationsReq.ownerUserID)
  return _s;
}
inline const std::string& getAllConversationsReq::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void getAllConversationsReq::_internal_set_owneruserid(const std::string& value) {
  ;


  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* getAllConversationsReq::_internal_mutable_owneruserid() {
  ;
  return _impl_.owneruserid_.Mutable( GetArenaForAllocation());
}
inline std::string* getAllConversationsReq::release_owneruserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.getAllConversationsReq.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void getAllConversationsReq::set_allocated_owneruserid(std::string* value) {
  _impl_.owneruserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owneruserid_.IsDefault()) {
          _impl_.owneruserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.getAllConversationsReq.ownerUserID)
}

// -------------------------------------------------------------------

// getAllConversationsResp

// repeated .ServerRpc.conversation.conversation conversations = 2;
inline int getAllConversationsResp::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int getAllConversationsResp::conversations_size() const {
  return _internal_conversations_size();
}
inline void getAllConversationsResp::clear_conversations() {
  _internal_mutable_conversations()->Clear();
}
inline ::ServerRpc::conversation::conversation* getAllConversationsResp::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getAllConversationsResp.conversations)
  return _internal_mutable_conversations()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >*
getAllConversationsResp::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.conversation.getAllConversationsResp.conversations)
  return _internal_mutable_conversations();
}
inline const ::ServerRpc::conversation::conversation& getAllConversationsResp::_internal_conversations(int index) const {
  return _internal_conversations().Get(index);
}
inline const ::ServerRpc::conversation::conversation& getAllConversationsResp::conversations(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getAllConversationsResp.conversations)
  return _internal_conversations(index);
}
inline ::ServerRpc::conversation::conversation* getAllConversationsResp::_internal_add_conversations() {
  return _internal_mutable_conversations()->Add();
}
inline ::ServerRpc::conversation::conversation* getAllConversationsResp::add_conversations() {
  ::ServerRpc::conversation::conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.getAllConversationsResp.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >&
getAllConversationsResp::conversations() const {
  // @@protoc_insertion_point(field_list:ServerRpc.conversation.getAllConversationsResp.conversations)
  return _internal_conversations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>&
getAllConversationsResp::_internal_conversations() const {
  return _impl_.conversations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>*
getAllConversationsResp::_internal_mutable_conversations() {
  return &_impl_.conversations_;
}

// -------------------------------------------------------------------

// batchSetConversationsReq

// repeated .ServerRpc.conversation.conversation conversations = 1;
inline int batchSetConversationsReq::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int batchSetConversationsReq::conversations_size() const {
  return _internal_conversations_size();
}
inline void batchSetConversationsReq::clear_conversations() {
  _internal_mutable_conversations()->Clear();
}
inline ::ServerRpc::conversation::conversation* batchSetConversationsReq::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.batchSetConversationsReq.conversations)
  return _internal_mutable_conversations()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >*
batchSetConversationsReq::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.conversation.batchSetConversationsReq.conversations)
  return _internal_mutable_conversations();
}
inline const ::ServerRpc::conversation::conversation& batchSetConversationsReq::_internal_conversations(int index) const {
  return _internal_conversations().Get(index);
}
inline const ::ServerRpc::conversation::conversation& batchSetConversationsReq::conversations(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.batchSetConversationsReq.conversations)
  return _internal_conversations(index);
}
inline ::ServerRpc::conversation::conversation* batchSetConversationsReq::_internal_add_conversations() {
  return _internal_mutable_conversations()->Add();
}
inline ::ServerRpc::conversation::conversation* batchSetConversationsReq::add_conversations() {
  ::ServerRpc::conversation::conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.batchSetConversationsReq.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >&
batchSetConversationsReq::conversations() const {
  // @@protoc_insertion_point(field_list:ServerRpc.conversation.batchSetConversationsReq.conversations)
  return _internal_conversations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>&
batchSetConversationsReq::_internal_conversations() const {
  return _impl_.conversations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>*
batchSetConversationsReq::_internal_mutable_conversations() {
  return &_impl_.conversations_;
}

// string ownerUserID = 2;
inline void batchSetConversationsReq::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& batchSetConversationsReq::owneruserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.batchSetConversationsReq.ownerUserID)
  return _internal_owneruserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void batchSetConversationsReq::set_owneruserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.owneruserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.batchSetConversationsReq.ownerUserID)
}
inline std::string* batchSetConversationsReq::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.batchSetConversationsReq.ownerUserID)
  return _s;
}
inline const std::string& batchSetConversationsReq::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void batchSetConversationsReq::_internal_set_owneruserid(const std::string& value) {
  ;


  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* batchSetConversationsReq::_internal_mutable_owneruserid() {
  ;
  return _impl_.owneruserid_.Mutable( GetArenaForAllocation());
}
inline std::string* batchSetConversationsReq::release_owneruserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.batchSetConversationsReq.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void batchSetConversationsReq::set_allocated_owneruserid(std::string* value) {
  _impl_.owneruserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owneruserid_.IsDefault()) {
          _impl_.owneruserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.batchSetConversationsReq.ownerUserID)
}

// -------------------------------------------------------------------

// batchSetConversationsResp

// -------------------------------------------------------------------

// createSingleChatConversationsReq

// string recvID = 1;
inline void createSingleChatConversationsReq::clear_recvid() {
  _impl_.recvid_.ClearToEmpty();
}
inline const std::string& createSingleChatConversationsReq::recvid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.createSingleChatConversationsReq.recvID)
  return _internal_recvid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void createSingleChatConversationsReq::set_recvid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.recvid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.createSingleChatConversationsReq.recvID)
}
inline std::string* createSingleChatConversationsReq::mutable_recvid() {
  std::string* _s = _internal_mutable_recvid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.createSingleChatConversationsReq.recvID)
  return _s;
}
inline const std::string& createSingleChatConversationsReq::_internal_recvid() const {
  return _impl_.recvid_.Get();
}
inline void createSingleChatConversationsReq::_internal_set_recvid(const std::string& value) {
  ;


  _impl_.recvid_.Set(value, GetArenaForAllocation());
}
inline std::string* createSingleChatConversationsReq::_internal_mutable_recvid() {
  ;
  return _impl_.recvid_.Mutable( GetArenaForAllocation());
}
inline std::string* createSingleChatConversationsReq::release_recvid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.createSingleChatConversationsReq.recvID)
  return _impl_.recvid_.Release();
}
inline void createSingleChatConversationsReq::set_allocated_recvid(std::string* value) {
  _impl_.recvid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recvid_.IsDefault()) {
          _impl_.recvid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.createSingleChatConversationsReq.recvID)
}

// string sendID = 2;
inline void createSingleChatConversationsReq::clear_sendid() {
  _impl_.sendid_.ClearToEmpty();
}
inline const std::string& createSingleChatConversationsReq::sendid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.createSingleChatConversationsReq.sendID)
  return _internal_sendid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void createSingleChatConversationsReq::set_sendid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sendid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.createSingleChatConversationsReq.sendID)
}
inline std::string* createSingleChatConversationsReq::mutable_sendid() {
  std::string* _s = _internal_mutable_sendid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.createSingleChatConversationsReq.sendID)
  return _s;
}
inline const std::string& createSingleChatConversationsReq::_internal_sendid() const {
  return _impl_.sendid_.Get();
}
inline void createSingleChatConversationsReq::_internal_set_sendid(const std::string& value) {
  ;


  _impl_.sendid_.Set(value, GetArenaForAllocation());
}
inline std::string* createSingleChatConversationsReq::_internal_mutable_sendid() {
  ;
  return _impl_.sendid_.Mutable( GetArenaForAllocation());
}
inline std::string* createSingleChatConversationsReq::release_sendid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.createSingleChatConversationsReq.sendID)
  return _impl_.sendid_.Release();
}
inline void createSingleChatConversationsReq::set_allocated_sendid(std::string* value) {
  _impl_.sendid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sendid_.IsDefault()) {
          _impl_.sendid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.createSingleChatConversationsReq.sendID)
}

// -------------------------------------------------------------------

// createSingleChatConversationsResp

// -------------------------------------------------------------------

// createGroupChatConversationsReq

// repeated string userIDs = 1;
inline int createGroupChatConversationsReq::_internal_userids_size() const {
  return _impl_.userids_.size();
}
inline int createGroupChatConversationsReq::userids_size() const {
  return _internal_userids_size();
}
inline void createGroupChatConversationsReq::clear_userids() {
  _internal_mutable_userids()->Clear();
}
inline std::string* createGroupChatConversationsReq::add_userids() {
  std::string* _s = _internal_add_userids();
  // @@protoc_insertion_point(field_add_mutable:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
  return _s;
}
inline const std::string& createGroupChatConversationsReq::userids(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
  return _internal_userids(index);
}
inline std::string* createGroupChatConversationsReq::mutable_userids(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
  return _internal_mutable_userids()->Mutable(index);
}
inline void createGroupChatConversationsReq::set_userids(int index, const std::string& value) {
  _internal_mutable_userids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline void createGroupChatConversationsReq::set_userids(int index, std::string&& value) {
  _internal_mutable_userids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline void createGroupChatConversationsReq::set_userids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_userids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline void createGroupChatConversationsReq::set_userids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_userids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline void createGroupChatConversationsReq::set_userids(int index, absl::string_view value) {
  _internal_mutable_userids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline void createGroupChatConversationsReq::add_userids(const std::string& value) {
  _internal_mutable_userids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline void createGroupChatConversationsReq::add_userids(std::string&& value) {
  _internal_mutable_userids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline void createGroupChatConversationsReq::add_userids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_userids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline void createGroupChatConversationsReq::add_userids(const char* value, std::size_t size) {
  _internal_mutable_userids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline void createGroupChatConversationsReq::add_userids(absl::string_view value) {
  _internal_mutable_userids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
createGroupChatConversationsReq::userids() const {
  // @@protoc_insertion_point(field_list:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
  return _internal_userids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* createGroupChatConversationsReq::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.conversation.createGroupChatConversationsReq.userIDs)
  return _internal_mutable_userids();
}
inline const std::string& createGroupChatConversationsReq::_internal_userids(int index) const {
  return _internal_userids().Get(index);
}
inline std::string* createGroupChatConversationsReq::_internal_add_userids() {
  return _internal_mutable_userids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
createGroupChatConversationsReq::_internal_userids() const {
  return _impl_.userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
createGroupChatConversationsReq::_internal_mutable_userids() {
  return &_impl_.userids_;
}

// string groupID = 2;
inline void createGroupChatConversationsReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& createGroupChatConversationsReq::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.createGroupChatConversationsReq.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void createGroupChatConversationsReq::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.createGroupChatConversationsReq.groupID)
}
inline std::string* createGroupChatConversationsReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.createGroupChatConversationsReq.groupID)
  return _s;
}
inline const std::string& createGroupChatConversationsReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void createGroupChatConversationsReq::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* createGroupChatConversationsReq::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* createGroupChatConversationsReq::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.createGroupChatConversationsReq.groupID)
  return _impl_.groupid_.Release();
}
inline void createGroupChatConversationsReq::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.createGroupChatConversationsReq.groupID)
}

// -------------------------------------------------------------------

// createGroupChatConversationsResp

// -------------------------------------------------------------------

// setConversationMaxSeqReq

// string conversationID = 1;
inline void setConversationMaxSeqReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& setConversationMaxSeqReq::conversationid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.setConversationMaxSeqReq.conversationID)
  return _internal_conversationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void setConversationMaxSeqReq::set_conversationid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.conversationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.setConversationMaxSeqReq.conversationID)
}
inline std::string* setConversationMaxSeqReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.setConversationMaxSeqReq.conversationID)
  return _s;
}
inline const std::string& setConversationMaxSeqReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void setConversationMaxSeqReq::_internal_set_conversationid(const std::string& value) {
  ;


  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* setConversationMaxSeqReq::_internal_mutable_conversationid() {
  ;
  return _impl_.conversationid_.Mutable( GetArenaForAllocation());
}
inline std::string* setConversationMaxSeqReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.setConversationMaxSeqReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void setConversationMaxSeqReq::set_allocated_conversationid(std::string* value) {
  _impl_.conversationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.conversationid_.IsDefault()) {
          _impl_.conversationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.setConversationMaxSeqReq.conversationID)
}

// repeated string ownerUserID = 2;
inline int setConversationMaxSeqReq::_internal_owneruserid_size() const {
  return _impl_.owneruserid_.size();
}
inline int setConversationMaxSeqReq::owneruserid_size() const {
  return _internal_owneruserid_size();
}
inline void setConversationMaxSeqReq::clear_owneruserid() {
  _internal_mutable_owneruserid()->Clear();
}
inline std::string* setConversationMaxSeqReq::add_owneruserid() {
  std::string* _s = _internal_add_owneruserid();
  // @@protoc_insertion_point(field_add_mutable:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
  return _s;
}
inline const std::string& setConversationMaxSeqReq::owneruserid(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
  return _internal_owneruserid(index);
}
inline std::string* setConversationMaxSeqReq::mutable_owneruserid(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
  return _internal_mutable_owneruserid()->Mutable(index);
}
inline void setConversationMaxSeqReq::set_owneruserid(int index, const std::string& value) {
  _internal_mutable_owneruserid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline void setConversationMaxSeqReq::set_owneruserid(int index, std::string&& value) {
  _internal_mutable_owneruserid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline void setConversationMaxSeqReq::set_owneruserid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_owneruserid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline void setConversationMaxSeqReq::set_owneruserid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_owneruserid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline void setConversationMaxSeqReq::set_owneruserid(int index, absl::string_view value) {
  _internal_mutable_owneruserid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline void setConversationMaxSeqReq::add_owneruserid(const std::string& value) {
  _internal_mutable_owneruserid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline void setConversationMaxSeqReq::add_owneruserid(std::string&& value) {
  _internal_mutable_owneruserid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline void setConversationMaxSeqReq::add_owneruserid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_owneruserid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline void setConversationMaxSeqReq::add_owneruserid(const char* value, std::size_t size) {
  _internal_mutable_owneruserid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline void setConversationMaxSeqReq::add_owneruserid(absl::string_view value) {
  _internal_mutable_owneruserid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
setConversationMaxSeqReq::owneruserid() const {
  // @@protoc_insertion_point(field_list:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
  return _internal_owneruserid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* setConversationMaxSeqReq::mutable_owneruserid() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.conversation.setConversationMaxSeqReq.ownerUserID)
  return _internal_mutable_owneruserid();
}
inline const std::string& setConversationMaxSeqReq::_internal_owneruserid(int index) const {
  return _internal_owneruserid().Get(index);
}
inline std::string* setConversationMaxSeqReq::_internal_add_owneruserid() {
  return _internal_mutable_owneruserid()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
setConversationMaxSeqReq::_internal_owneruserid() const {
  return _impl_.owneruserid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
setConversationMaxSeqReq::_internal_mutable_owneruserid() {
  return &_impl_.owneruserid_;
}

// int64 maxSeq = 3;
inline void setConversationMaxSeqReq::clear_maxseq() {
  _impl_.maxseq_ = ::int64_t{0};
}
inline ::int64_t setConversationMaxSeqReq::maxseq() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.setConversationMaxSeqReq.maxSeq)
  return _internal_maxseq();
}
inline void setConversationMaxSeqReq::set_maxseq(::int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.setConversationMaxSeqReq.maxSeq)
}
inline ::int64_t setConversationMaxSeqReq::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline void setConversationMaxSeqReq::_internal_set_maxseq(::int64_t value) {
  ;
  _impl_.maxseq_ = value;
}

// -------------------------------------------------------------------

// setConversationMaxSeqResp

// -------------------------------------------------------------------

// getConversationIDsReq

// string userID = 1;
inline void getConversationIDsReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& getConversationIDsReq::userid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationIDsReq.userID)
  return _internal_userid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getConversationIDsReq::set_userid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.userid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationIDsReq.userID)
}
inline std::string* getConversationIDsReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationIDsReq.userID)
  return _s;
}
inline const std::string& getConversationIDsReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void getConversationIDsReq::_internal_set_userid(const std::string& value) {
  ;


  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* getConversationIDsReq::_internal_mutable_userid() {
  ;
  return _impl_.userid_.Mutable( GetArenaForAllocation());
}
inline std::string* getConversationIDsReq::release_userid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.getConversationIDsReq.userID)
  return _impl_.userid_.Release();
}
inline void getConversationIDsReq::set_allocated_userid(std::string* value) {
  _impl_.userid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userid_.IsDefault()) {
          _impl_.userid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.getConversationIDsReq.userID)
}

// -------------------------------------------------------------------

// getConversationIDsResp

// repeated string conversationIDs = 1;
inline int getConversationIDsResp::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int getConversationIDsResp::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void getConversationIDsResp::clear_conversationids() {
  _internal_mutable_conversationids()->Clear();
}
inline std::string* getConversationIDsResp::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
  return _s;
}
inline const std::string& getConversationIDsResp::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* getConversationIDsResp::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
  return _internal_mutable_conversationids()->Mutable(index);
}
inline void getConversationIDsResp::set_conversationids(int index, const std::string& value) {
  _internal_mutable_conversationids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline void getConversationIDsResp::set_conversationids(int index, std::string&& value) {
  _internal_mutable_conversationids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline void getConversationIDsResp::set_conversationids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_conversationids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline void getConversationIDsResp::set_conversationids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_conversationids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline void getConversationIDsResp::set_conversationids(int index, absl::string_view value) {
  _internal_mutable_conversationids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline void getConversationIDsResp::add_conversationids(const std::string& value) {
  _internal_mutable_conversationids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline void getConversationIDsResp::add_conversationids(std::string&& value) {
  _internal_mutable_conversationids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline void getConversationIDsResp::add_conversationids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_conversationids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline void getConversationIDsResp::add_conversationids(const char* value, std::size_t size) {
  _internal_mutable_conversationids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline void getConversationIDsResp::add_conversationids(absl::string_view value) {
  _internal_mutable_conversationids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
getConversationIDsResp::conversationids() const {
  // @@protoc_insertion_point(field_list:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
  return _internal_conversationids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* getConversationIDsResp::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.conversation.getConversationIDsResp.conversationIDs)
  return _internal_mutable_conversationids();
}
inline const std::string& getConversationIDsResp::_internal_conversationids(int index) const {
  return _internal_conversationids().Get(index);
}
inline std::string* getConversationIDsResp::_internal_add_conversationids() {
  return _internal_mutable_conversationids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
getConversationIDsResp::_internal_conversationids() const {
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
getConversationIDsResp::_internal_mutable_conversationids() {
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// getUserConversationIDsHashReq

// string ownerUserID = 1;
inline void getUserConversationIDsHashReq::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& getUserConversationIDsHashReq::owneruserid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getUserConversationIDsHashReq.ownerUserID)
  return _internal_owneruserid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getUserConversationIDsHashReq::set_owneruserid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.owneruserid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getUserConversationIDsHashReq.ownerUserID)
}
inline std::string* getUserConversationIDsHashReq::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getUserConversationIDsHashReq.ownerUserID)
  return _s;
}
inline const std::string& getUserConversationIDsHashReq::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void getUserConversationIDsHashReq::_internal_set_owneruserid(const std::string& value) {
  ;


  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* getUserConversationIDsHashReq::_internal_mutable_owneruserid() {
  ;
  return _impl_.owneruserid_.Mutable( GetArenaForAllocation());
}
inline std::string* getUserConversationIDsHashReq::release_owneruserid() {
  // @@protoc_insertion_point(field_release:ServerRpc.conversation.getUserConversationIDsHashReq.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void getUserConversationIDsHashReq::set_allocated_owneruserid(std::string* value) {
  _impl_.owneruserid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owneruserid_.IsDefault()) {
          _impl_.owneruserid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.conversation.getUserConversationIDsHashReq.ownerUserID)
}

// -------------------------------------------------------------------

// getUserConversationIDsHashResp

// uint64 hash = 1;
inline void getUserConversationIDsHashResp::clear_hash() {
  _impl_.hash_ = ::uint64_t{0u};
}
inline ::uint64_t getUserConversationIDsHashResp::hash() const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getUserConversationIDsHashResp.hash)
  return _internal_hash();
}
inline void getUserConversationIDsHashResp::set_hash(::uint64_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getUserConversationIDsHashResp.hash)
}
inline ::uint64_t getUserConversationIDsHashResp::_internal_hash() const {
  return _impl_.hash_;
}
inline void getUserConversationIDsHashResp::_internal_set_hash(::uint64_t value) {
  ;
  _impl_.hash_ = value;
}

// -------------------------------------------------------------------

// getConversationsByConversationIDReq

// repeated string conversationIDs = 1;
inline int getConversationsByConversationIDReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int getConversationsByConversationIDReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void getConversationsByConversationIDReq::clear_conversationids() {
  _internal_mutable_conversationids()->Clear();
}
inline std::string* getConversationsByConversationIDReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
  return _s;
}
inline const std::string& getConversationsByConversationIDReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* getConversationsByConversationIDReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
  return _internal_mutable_conversationids()->Mutable(index);
}
inline void getConversationsByConversationIDReq::set_conversationids(int index, const std::string& value) {
  _internal_mutable_conversationids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline void getConversationsByConversationIDReq::set_conversationids(int index, std::string&& value) {
  _internal_mutable_conversationids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline void getConversationsByConversationIDReq::set_conversationids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_conversationids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline void getConversationsByConversationIDReq::set_conversationids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_conversationids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline void getConversationsByConversationIDReq::set_conversationids(int index, absl::string_view value) {
  _internal_mutable_conversationids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline void getConversationsByConversationIDReq::add_conversationids(const std::string& value) {
  _internal_mutable_conversationids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline void getConversationsByConversationIDReq::add_conversationids(std::string&& value) {
  _internal_mutable_conversationids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline void getConversationsByConversationIDReq::add_conversationids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_conversationids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline void getConversationsByConversationIDReq::add_conversationids(const char* value, std::size_t size) {
  _internal_mutable_conversationids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline void getConversationsByConversationIDReq::add_conversationids(absl::string_view value) {
  _internal_mutable_conversationids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
getConversationsByConversationIDReq::conversationids() const {
  // @@protoc_insertion_point(field_list:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
  return _internal_conversationids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* getConversationsByConversationIDReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.conversation.getConversationsByConversationIDReq.conversationIDs)
  return _internal_mutable_conversationids();
}
inline const std::string& getConversationsByConversationIDReq::_internal_conversationids(int index) const {
  return _internal_conversationids().Get(index);
}
inline std::string* getConversationsByConversationIDReq::_internal_add_conversationids() {
  return _internal_mutable_conversationids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
getConversationsByConversationIDReq::_internal_conversationids() const {
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
getConversationsByConversationIDReq::_internal_mutable_conversationids() {
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// getConversationsByConversationIDResp

// repeated .ServerRpc.conversation.conversation conversations = 1;
inline int getConversationsByConversationIDResp::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int getConversationsByConversationIDResp::conversations_size() const {
  return _internal_conversations_size();
}
inline void getConversationsByConversationIDResp::clear_conversations() {
  _internal_mutable_conversations()->Clear();
}
inline ::ServerRpc::conversation::conversation* getConversationsByConversationIDResp::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.conversation.getConversationsByConversationIDResp.conversations)
  return _internal_mutable_conversations()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >*
getConversationsByConversationIDResp::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.conversation.getConversationsByConversationIDResp.conversations)
  return _internal_mutable_conversations();
}
inline const ::ServerRpc::conversation::conversation& getConversationsByConversationIDResp::_internal_conversations(int index) const {
  return _internal_conversations().Get(index);
}
inline const ::ServerRpc::conversation::conversation& getConversationsByConversationIDResp::conversations(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.conversation.getConversationsByConversationIDResp.conversations)
  return _internal_conversations(index);
}
inline ::ServerRpc::conversation::conversation* getConversationsByConversationIDResp::_internal_add_conversations() {
  return _internal_mutable_conversations()->Add();
}
inline ::ServerRpc::conversation::conversation* getConversationsByConversationIDResp::add_conversations() {
  ::ServerRpc::conversation::conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:ServerRpc.conversation.getConversationsByConversationIDResp.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::conversation::conversation >&
getConversationsByConversationIDResp::conversations() const {
  // @@protoc_insertion_point(field_list:ServerRpc.conversation.getConversationsByConversationIDResp.conversations)
  return _internal_conversations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>&
getConversationsByConversationIDResp::_internal_conversations() const {
  return _impl_.conversations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::conversation::conversation>*
getConversationsByConversationIDResp::_internal_mutable_conversations() {
  return &_impl_.conversations_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace conversation
}  // namespace ServerRpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_conversation_2eproto_2epb_2eh
