// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: group.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_group_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_group_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "user.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_group_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_group_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_group_2eproto;
namespace ServerRpc {
namespace group {
class createGroupReq;
struct createGroupReqDefaultTypeInternal;
extern createGroupReqDefaultTypeInternal _createGroupReq_default_instance_;
class createGroupResp;
struct createGroupRespDefaultTypeInternal;
extern createGroupRespDefaultTypeInternal _createGroupResp_default_instance_;
class getGroupInfoReq;
struct getGroupInfoReqDefaultTypeInternal;
extern getGroupInfoReqDefaultTypeInternal _getGroupInfoReq_default_instance_;
class getGroupInfoResp;
struct getGroupInfoRespDefaultTypeInternal;
extern getGroupInfoRespDefaultTypeInternal _getGroupInfoResp_default_instance_;
class getGroupListReq;
struct getGroupListReqDefaultTypeInternal;
extern getGroupListReqDefaultTypeInternal _getGroupListReq_default_instance_;
class getGroupListResp;
struct getGroupListRespDefaultTypeInternal;
extern getGroupListRespDefaultTypeInternal _getGroupListResp_default_instance_;
class getGroupMemberReq;
struct getGroupMemberReqDefaultTypeInternal;
extern getGroupMemberReqDefaultTypeInternal _getGroupMemberReq_default_instance_;
class getGroupMemberResp;
struct getGroupMemberRespDefaultTypeInternal;
extern getGroupMemberRespDefaultTypeInternal _getGroupMemberResp_default_instance_;
class groupInfo;
struct groupInfoDefaultTypeInternal;
extern groupInfoDefaultTypeInternal _groupInfo_default_instance_;
class groupMember;
struct groupMemberDefaultTypeInternal;
extern groupMemberDefaultTypeInternal _groupMember_default_instance_;
class joinGroupReq;
struct joinGroupReqDefaultTypeInternal;
extern joinGroupReqDefaultTypeInternal _joinGroupReq_default_instance_;
class joinGroupResp;
struct joinGroupRespDefaultTypeInternal;
extern joinGroupRespDefaultTypeInternal _joinGroupResp_default_instance_;
}  // namespace group
}  // namespace ServerRpc
PROTOBUF_NAMESPACE_OPEN
template <>
::ServerRpc::group::createGroupReq* Arena::CreateMaybeMessage<::ServerRpc::group::createGroupReq>(Arena*);
template <>
::ServerRpc::group::createGroupResp* Arena::CreateMaybeMessage<::ServerRpc::group::createGroupResp>(Arena*);
template <>
::ServerRpc::group::getGroupInfoReq* Arena::CreateMaybeMessage<::ServerRpc::group::getGroupInfoReq>(Arena*);
template <>
::ServerRpc::group::getGroupInfoResp* Arena::CreateMaybeMessage<::ServerRpc::group::getGroupInfoResp>(Arena*);
template <>
::ServerRpc::group::getGroupListReq* Arena::CreateMaybeMessage<::ServerRpc::group::getGroupListReq>(Arena*);
template <>
::ServerRpc::group::getGroupListResp* Arena::CreateMaybeMessage<::ServerRpc::group::getGroupListResp>(Arena*);
template <>
::ServerRpc::group::getGroupMemberReq* Arena::CreateMaybeMessage<::ServerRpc::group::getGroupMemberReq>(Arena*);
template <>
::ServerRpc::group::getGroupMemberResp* Arena::CreateMaybeMessage<::ServerRpc::group::getGroupMemberResp>(Arena*);
template <>
::ServerRpc::group::groupInfo* Arena::CreateMaybeMessage<::ServerRpc::group::groupInfo>(Arena*);
template <>
::ServerRpc::group::groupMember* Arena::CreateMaybeMessage<::ServerRpc::group::groupMember>(Arena*);
template <>
::ServerRpc::group::joinGroupReq* Arena::CreateMaybeMessage<::ServerRpc::group::joinGroupReq>(Arena*);
template <>
::ServerRpc::group::joinGroupResp* Arena::CreateMaybeMessage<::ServerRpc::group::joinGroupResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace ServerRpc {
namespace group {
enum groupMember_groupMemberRole : int {
  groupMember_groupMemberRole_owner = 0,
  groupMember_groupMemberRole_member = 1,
  groupMember_groupMemberRole_groupMember_groupMemberRole_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  groupMember_groupMemberRole_groupMember_groupMemberRole_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool groupMember_groupMemberRole_IsValid(int value);
constexpr groupMember_groupMemberRole groupMember_groupMemberRole_groupMemberRole_MIN = static_cast<groupMember_groupMemberRole>(0);
constexpr groupMember_groupMemberRole groupMember_groupMemberRole_groupMemberRole_MAX = static_cast<groupMember_groupMemberRole>(1);
constexpr int groupMember_groupMemberRole_groupMemberRole_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
groupMember_groupMemberRole_descriptor();
template <typename T>
const std::string& groupMember_groupMemberRole_Name(T value) {
  static_assert(std::is_same<T, groupMember_groupMemberRole>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to groupMemberRole_Name().");
  return groupMember_groupMemberRole_Name(static_cast<groupMember_groupMemberRole>(value));
}
template <>
inline const std::string& groupMember_groupMemberRole_Name(groupMember_groupMemberRole value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<groupMember_groupMemberRole_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool groupMember_groupMemberRole_Parse(absl::string_view name, groupMember_groupMemberRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<groupMember_groupMemberRole>(
      groupMember_groupMemberRole_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class groupMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.groupMember) */ {
 public:
  inline groupMember() : groupMember(nullptr) {}
  ~groupMember() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR groupMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  groupMember(const groupMember& from);
  groupMember(groupMember&& from) noexcept
    : groupMember() {
    *this = ::std::move(from);
  }

  inline groupMember& operator=(const groupMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline groupMember& operator=(groupMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const groupMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const groupMember* internal_default_instance() {
    return reinterpret_cast<const groupMember*>(
               &_groupMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(groupMember& a, groupMember& b) {
    a.Swap(&b);
  }
  inline void Swap(groupMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(groupMember* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  groupMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<groupMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const groupMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const groupMember& from) {
    groupMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(groupMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.groupMember";
  }
  protected:
  explicit groupMember(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using groupMemberRole = groupMember_groupMemberRole;
  static constexpr groupMemberRole owner = groupMember_groupMemberRole_owner;
  static constexpr groupMemberRole member = groupMember_groupMemberRole_member;
  static inline bool groupMemberRole_IsValid(int value) {
    return groupMember_groupMemberRole_IsValid(value);
  }
  static constexpr groupMemberRole groupMemberRole_MIN = groupMember_groupMemberRole_groupMemberRole_MIN;
  static constexpr groupMemberRole groupMemberRole_MAX = groupMember_groupMemberRole_groupMemberRole_MAX;
  static constexpr int groupMemberRole_ARRAYSIZE = groupMember_groupMemberRole_groupMemberRole_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* groupMemberRole_descriptor() {
    return groupMember_groupMemberRole_descriptor();
  }
  template <typename T>
  static inline const std::string& groupMemberRole_Name(T value) {
    return groupMember_groupMemberRole_Name(value);
  }
  static inline bool groupMemberRole_Parse(absl::string_view name, groupMemberRole* value) {
    return groupMember_groupMemberRole_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIDFieldNumber = 2,
    kUserFieldNumber = 1,
    kRoleFieldNumber = 3,
  };
  // string groupID = 2;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // .ServerRpc.user.user user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::ServerRpc::user::user& user() const;
  PROTOBUF_NODISCARD ::ServerRpc::user::user* release_user();
  ::ServerRpc::user::user* mutable_user();
  void set_allocated_user(::ServerRpc::user::user* user);
  private:
  const ::ServerRpc::user::user& _internal_user() const;
  ::ServerRpc::user::user* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::ServerRpc::user::user* user);
  ::ServerRpc::user::user* unsafe_arena_release_user();
  // .ServerRpc.group.groupMember.groupMemberRole role = 3;
  void clear_role() ;
  ::ServerRpc::group::groupMember_groupMemberRole role() const;
  void set_role(::ServerRpc::group::groupMember_groupMemberRole value);

  private:
  ::ServerRpc::group::groupMember_groupMemberRole _internal_role() const;
  void _internal_set_role(::ServerRpc::group::groupMember_groupMemberRole value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.group.groupMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::ServerRpc::user::user* user_;
    int role_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class groupInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.groupInfo) */ {
 public:
  inline groupInfo() : groupInfo(nullptr) {}
  ~groupInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR groupInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  groupInfo(const groupInfo& from);
  groupInfo(groupInfo&& from) noexcept
    : groupInfo() {
    *this = ::std::move(from);
  }

  inline groupInfo& operator=(const groupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline groupInfo& operator=(groupInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const groupInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const groupInfo* internal_default_instance() {
    return reinterpret_cast<const groupInfo*>(
               &_groupInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(groupInfo& a, groupInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(groupInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(groupInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  groupInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<groupInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const groupInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const groupInfo& from) {
    groupInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(groupInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.groupInfo";
  }
  protected:
  explicit groupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupMembersFieldNumber = 5,
    kGroupNameFieldNumber = 1,
    kGroupDescFieldNumber = 2,
    kGroupOwnerIdFieldNumber = 3,
    kGroupIdFieldNumber = 4,
  };
  // repeated .ServerRpc.group.groupMember groupMembers = 5;
  int groupmembers_size() const;
  private:
  int _internal_groupmembers_size() const;

  public:
  void clear_groupmembers() ;
  ::ServerRpc::group::groupMember* mutable_groupmembers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember >*
      mutable_groupmembers();
  private:
  const ::ServerRpc::group::groupMember& _internal_groupmembers(int index) const;
  ::ServerRpc::group::groupMember* _internal_add_groupmembers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupMember>& _internal_groupmembers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupMember>* _internal_mutable_groupmembers();
  public:
  const ::ServerRpc::group::groupMember& groupmembers(int index) const;
  ::ServerRpc::group::groupMember* add_groupmembers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember >&
      groupmembers() const;
  // string groupName = 1;
  void clear_groupname() ;
  const std::string& groupname() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupname(Arg_&& arg, Args_... args);
  std::string* mutable_groupname();
  PROTOBUF_NODISCARD std::string* release_groupname();
  void set_allocated_groupname(std::string* ptr);

  private:
  const std::string& _internal_groupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupname(
      const std::string& value);
  std::string* _internal_mutable_groupname();

  public:
  // string groupDesc = 2;
  void clear_groupdesc() ;
  const std::string& groupdesc() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupdesc(Arg_&& arg, Args_... args);
  std::string* mutable_groupdesc();
  PROTOBUF_NODISCARD std::string* release_groupdesc();
  void set_allocated_groupdesc(std::string* ptr);

  private:
  const std::string& _internal_groupdesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupdesc(
      const std::string& value);
  std::string* _internal_mutable_groupdesc();

  public:
  // string groupOwnerId = 3;
  void clear_groupownerid() ;
  const std::string& groupownerid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupownerid(Arg_&& arg, Args_... args);
  std::string* mutable_groupownerid();
  PROTOBUF_NODISCARD std::string* release_groupownerid();
  void set_allocated_groupownerid(std::string* ptr);

  private:
  const std::string& _internal_groupownerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupownerid(
      const std::string& value);
  std::string* _internal_mutable_groupownerid();

  public:
  // string groupId = 4;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.group.groupInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember > groupmembers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupdesc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupownerid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class createGroupReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.createGroupReq) */ {
 public:
  inline createGroupReq() : createGroupReq(nullptr) {}
  ~createGroupReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR createGroupReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createGroupReq(const createGroupReq& from);
  createGroupReq(createGroupReq&& from) noexcept
    : createGroupReq() {
    *this = ::std::move(from);
  }

  inline createGroupReq& operator=(const createGroupReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline createGroupReq& operator=(createGroupReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createGroupReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const createGroupReq* internal_default_instance() {
    return reinterpret_cast<const createGroupReq*>(
               &_createGroupReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(createGroupReq& a, createGroupReq& b) {
    a.Swap(&b);
  }
  inline void Swap(createGroupReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createGroupReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createGroupReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createGroupReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const createGroupReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const createGroupReq& from) {
    createGroupReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(createGroupReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.createGroupReq";
  }
  protected:
  explicit createGroupReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupMemberIdsFieldNumber = 5,
    kGroupNameFieldNumber = 1,
    kGroupDescFieldNumber = 2,
    kGroupOwnerIdFieldNumber = 3,
    kGroupIdFieldNumber = 4,
  };
  // repeated string groupMemberIds = 5;
  int groupmemberids_size() const;
  private:
  int _internal_groupmemberids_size() const;

  public:
  void clear_groupmemberids() ;
  const std::string& groupmemberids(int index) const;
  std::string* mutable_groupmemberids(int index);
  void set_groupmemberids(int index, const std::string& value);
  void set_groupmemberids(int index, std::string&& value);
  void set_groupmemberids(int index, const char* value);
  void set_groupmemberids(int index, const char* value, std::size_t size);
  void set_groupmemberids(int index, absl::string_view value);
  std::string* add_groupmemberids();
  void add_groupmemberids(const std::string& value);
  void add_groupmemberids(std::string&& value);
  void add_groupmemberids(const char* value);
  void add_groupmemberids(const char* value, std::size_t size);
  void add_groupmemberids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groupmemberids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groupmemberids();

  private:
  const std::string& _internal_groupmemberids(int index) const;
  std::string* _internal_add_groupmemberids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_groupmemberids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_groupmemberids();

  public:
  // string groupName = 1;
  void clear_groupname() ;
  const std::string& groupname() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupname(Arg_&& arg, Args_... args);
  std::string* mutable_groupname();
  PROTOBUF_NODISCARD std::string* release_groupname();
  void set_allocated_groupname(std::string* ptr);

  private:
  const std::string& _internal_groupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupname(
      const std::string& value);
  std::string* _internal_mutable_groupname();

  public:
  // string groupDesc = 2;
  void clear_groupdesc() ;
  const std::string& groupdesc() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupdesc(Arg_&& arg, Args_... args);
  std::string* mutable_groupdesc();
  PROTOBUF_NODISCARD std::string* release_groupdesc();
  void set_allocated_groupdesc(std::string* ptr);

  private:
  const std::string& _internal_groupdesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupdesc(
      const std::string& value);
  std::string* _internal_mutable_groupdesc();

  public:
  // string groupOwnerId = 3;
  void clear_groupownerid() ;
  const std::string& groupownerid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupownerid(Arg_&& arg, Args_... args);
  std::string* mutable_groupownerid();
  PROTOBUF_NODISCARD std::string* release_groupownerid();
  void set_allocated_groupownerid(std::string* ptr);

  private:
  const std::string& _internal_groupownerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupownerid(
      const std::string& value);
  std::string* _internal_mutable_groupownerid();

  public:
  // string groupId = 4;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.group.createGroupReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groupmemberids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupdesc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupownerid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class createGroupResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerRpc.group.createGroupResp) */ {
 public:
  inline createGroupResp() : createGroupResp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR createGroupResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createGroupResp(const createGroupResp& from);
  createGroupResp(createGroupResp&& from) noexcept
    : createGroupResp() {
    *this = ::std::move(from);
  }

  inline createGroupResp& operator=(const createGroupResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline createGroupResp& operator=(createGroupResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createGroupResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const createGroupResp* internal_default_instance() {
    return reinterpret_cast<const createGroupResp*>(
               &_createGroupResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(createGroupResp& a, createGroupResp& b) {
    a.Swap(&b);
  }
  inline void Swap(createGroupResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createGroupResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createGroupResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createGroupResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const createGroupResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const createGroupResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.createGroupResp";
  }
  protected:
  explicit createGroupResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerRpc.group.createGroupResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class joinGroupReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.joinGroupReq) */ {
 public:
  inline joinGroupReq() : joinGroupReq(nullptr) {}
  ~joinGroupReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR joinGroupReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  joinGroupReq(const joinGroupReq& from);
  joinGroupReq(joinGroupReq&& from) noexcept
    : joinGroupReq() {
    *this = ::std::move(from);
  }

  inline joinGroupReq& operator=(const joinGroupReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline joinGroupReq& operator=(joinGroupReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const joinGroupReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const joinGroupReq* internal_default_instance() {
    return reinterpret_cast<const joinGroupReq*>(
               &_joinGroupReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(joinGroupReq& a, joinGroupReq& b) {
    a.Swap(&b);
  }
  inline void Swap(joinGroupReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(joinGroupReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  joinGroupReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<joinGroupReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const joinGroupReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const joinGroupReq& from) {
    joinGroupReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(joinGroupReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.joinGroupReq";
  }
  protected:
  explicit joinGroupReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIDFieldNumber = 1,
    kUserIDFieldNumber = 2,
  };
  // string groupID = 1;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // string userID = 2;
  void clear_userid() ;
  const std::string& userid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userid(Arg_&& arg, Args_... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* ptr);

  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(
      const std::string& value);
  std::string* _internal_mutable_userid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.group.joinGroupReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class joinGroupResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerRpc.group.joinGroupResp) */ {
 public:
  inline joinGroupResp() : joinGroupResp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR joinGroupResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  joinGroupResp(const joinGroupResp& from);
  joinGroupResp(joinGroupResp&& from) noexcept
    : joinGroupResp() {
    *this = ::std::move(from);
  }

  inline joinGroupResp& operator=(const joinGroupResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline joinGroupResp& operator=(joinGroupResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const joinGroupResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const joinGroupResp* internal_default_instance() {
    return reinterpret_cast<const joinGroupResp*>(
               &_joinGroupResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(joinGroupResp& a, joinGroupResp& b) {
    a.Swap(&b);
  }
  inline void Swap(joinGroupResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(joinGroupResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  joinGroupResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<joinGroupResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const joinGroupResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const joinGroupResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.joinGroupResp";
  }
  protected:
  explicit joinGroupResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerRpc.group.joinGroupResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class getGroupInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.getGroupInfoReq) */ {
 public:
  inline getGroupInfoReq() : getGroupInfoReq(nullptr) {}
  ~getGroupInfoReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getGroupInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getGroupInfoReq(const getGroupInfoReq& from);
  getGroupInfoReq(getGroupInfoReq&& from) noexcept
    : getGroupInfoReq() {
    *this = ::std::move(from);
  }

  inline getGroupInfoReq& operator=(const getGroupInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getGroupInfoReq& operator=(getGroupInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getGroupInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getGroupInfoReq* internal_default_instance() {
    return reinterpret_cast<const getGroupInfoReq*>(
               &_getGroupInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(getGroupInfoReq& a, getGroupInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getGroupInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getGroupInfoReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getGroupInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getGroupInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getGroupInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getGroupInfoReq& from) {
    getGroupInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getGroupInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.getGroupInfoReq";
  }
  protected:
  explicit getGroupInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIDFieldNumber = 1,
  };
  // string groupID = 1;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.group.getGroupInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class getGroupInfoResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.getGroupInfoResp) */ {
 public:
  inline getGroupInfoResp() : getGroupInfoResp(nullptr) {}
  ~getGroupInfoResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getGroupInfoResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getGroupInfoResp(const getGroupInfoResp& from);
  getGroupInfoResp(getGroupInfoResp&& from) noexcept
    : getGroupInfoResp() {
    *this = ::std::move(from);
  }

  inline getGroupInfoResp& operator=(const getGroupInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getGroupInfoResp& operator=(getGroupInfoResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getGroupInfoResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getGroupInfoResp* internal_default_instance() {
    return reinterpret_cast<const getGroupInfoResp*>(
               &_getGroupInfoResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(getGroupInfoResp& a, getGroupInfoResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getGroupInfoResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getGroupInfoResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getGroupInfoResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getGroupInfoResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getGroupInfoResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getGroupInfoResp& from) {
    getGroupInfoResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getGroupInfoResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.getGroupInfoResp";
  }
  protected:
  explicit getGroupInfoResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupInfoFieldNumber = 2,
  };
  // .ServerRpc.group.groupInfo groupInfo = 2;
  bool has_groupinfo() const;
  void clear_groupinfo() ;
  const ::ServerRpc::group::groupInfo& groupinfo() const;
  PROTOBUF_NODISCARD ::ServerRpc::group::groupInfo* release_groupinfo();
  ::ServerRpc::group::groupInfo* mutable_groupinfo();
  void set_allocated_groupinfo(::ServerRpc::group::groupInfo* groupinfo);
  private:
  const ::ServerRpc::group::groupInfo& _internal_groupinfo() const;
  ::ServerRpc::group::groupInfo* _internal_mutable_groupinfo();
  public:
  void unsafe_arena_set_allocated_groupinfo(
      ::ServerRpc::group::groupInfo* groupinfo);
  ::ServerRpc::group::groupInfo* unsafe_arena_release_groupinfo();
  // @@protoc_insertion_point(class_scope:ServerRpc.group.getGroupInfoResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ServerRpc::group::groupInfo* groupinfo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class getGroupListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.getGroupListReq) */ {
 public:
  inline getGroupListReq() : getGroupListReq(nullptr) {}
  ~getGroupListReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getGroupListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getGroupListReq(const getGroupListReq& from);
  getGroupListReq(getGroupListReq&& from) noexcept
    : getGroupListReq() {
    *this = ::std::move(from);
  }

  inline getGroupListReq& operator=(const getGroupListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getGroupListReq& operator=(getGroupListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getGroupListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getGroupListReq* internal_default_instance() {
    return reinterpret_cast<const getGroupListReq*>(
               &_getGroupListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(getGroupListReq& a, getGroupListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getGroupListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getGroupListReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getGroupListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getGroupListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getGroupListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getGroupListReq& from) {
    getGroupListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getGroupListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.getGroupListReq";
  }
  protected:
  explicit getGroupListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid() ;
  const std::string& userid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userid(Arg_&& arg, Args_... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* ptr);

  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(
      const std::string& value);
  std::string* _internal_mutable_userid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.group.getGroupListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class getGroupListResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.getGroupListResp) */ {
 public:
  inline getGroupListResp() : getGroupListResp(nullptr) {}
  ~getGroupListResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getGroupListResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getGroupListResp(const getGroupListResp& from);
  getGroupListResp(getGroupListResp&& from) noexcept
    : getGroupListResp() {
    *this = ::std::move(from);
  }

  inline getGroupListResp& operator=(const getGroupListResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getGroupListResp& operator=(getGroupListResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getGroupListResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getGroupListResp* internal_default_instance() {
    return reinterpret_cast<const getGroupListResp*>(
               &_getGroupListResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(getGroupListResp& a, getGroupListResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getGroupListResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getGroupListResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getGroupListResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getGroupListResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getGroupListResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getGroupListResp& from) {
    getGroupListResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getGroupListResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.getGroupListResp";
  }
  protected:
  explicit getGroupListResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupInfoFieldNumber = 2,
  };
  // repeated .ServerRpc.group.groupInfo groupInfo = 2;
  int groupinfo_size() const;
  private:
  int _internal_groupinfo_size() const;

  public:
  void clear_groupinfo() ;
  ::ServerRpc::group::groupInfo* mutable_groupinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupInfo >*
      mutable_groupinfo();
  private:
  const ::ServerRpc::group::groupInfo& _internal_groupinfo(int index) const;
  ::ServerRpc::group::groupInfo* _internal_add_groupinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupInfo>& _internal_groupinfo() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupInfo>* _internal_mutable_groupinfo();
  public:
  const ::ServerRpc::group::groupInfo& groupinfo(int index) const;
  ::ServerRpc::group::groupInfo* add_groupinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupInfo >&
      groupinfo() const;
  // @@protoc_insertion_point(class_scope:ServerRpc.group.getGroupListResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupInfo > groupinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class getGroupMemberReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.getGroupMemberReq) */ {
 public:
  inline getGroupMemberReq() : getGroupMemberReq(nullptr) {}
  ~getGroupMemberReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getGroupMemberReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getGroupMemberReq(const getGroupMemberReq& from);
  getGroupMemberReq(getGroupMemberReq&& from) noexcept
    : getGroupMemberReq() {
    *this = ::std::move(from);
  }

  inline getGroupMemberReq& operator=(const getGroupMemberReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline getGroupMemberReq& operator=(getGroupMemberReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getGroupMemberReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const getGroupMemberReq* internal_default_instance() {
    return reinterpret_cast<const getGroupMemberReq*>(
               &_getGroupMemberReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(getGroupMemberReq& a, getGroupMemberReq& b) {
    a.Swap(&b);
  }
  inline void Swap(getGroupMemberReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getGroupMemberReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getGroupMemberReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getGroupMemberReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getGroupMemberReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getGroupMemberReq& from) {
    getGroupMemberReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getGroupMemberReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.getGroupMemberReq";
  }
  protected:
  explicit getGroupMemberReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIDFieldNumber = 1,
  };
  // string groupID = 1;
  void clear_groupid() ;
  const std::string& groupid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupid(Arg_&& arg, Args_... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* ptr);

  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(
      const std::string& value);
  std::string* _internal_mutable_groupid();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.group.getGroupMemberReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};// -------------------------------------------------------------------

class getGroupMemberResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.group.getGroupMemberResp) */ {
 public:
  inline getGroupMemberResp() : getGroupMemberResp(nullptr) {}
  ~getGroupMemberResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getGroupMemberResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getGroupMemberResp(const getGroupMemberResp& from);
  getGroupMemberResp(getGroupMemberResp&& from) noexcept
    : getGroupMemberResp() {
    *this = ::std::move(from);
  }

  inline getGroupMemberResp& operator=(const getGroupMemberResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline getGroupMemberResp& operator=(getGroupMemberResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getGroupMemberResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const getGroupMemberResp* internal_default_instance() {
    return reinterpret_cast<const getGroupMemberResp*>(
               &_getGroupMemberResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(getGroupMemberResp& a, getGroupMemberResp& b) {
    a.Swap(&b);
  }
  inline void Swap(getGroupMemberResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getGroupMemberResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getGroupMemberResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getGroupMemberResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getGroupMemberResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getGroupMemberResp& from) {
    getGroupMemberResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getGroupMemberResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.group.getGroupMemberResp";
  }
  protected:
  explicit getGroupMemberResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupMembersFieldNumber = 2,
  };
  // repeated .ServerRpc.group.groupMember groupMembers = 2;
  int groupmembers_size() const;
  private:
  int _internal_groupmembers_size() const;

  public:
  void clear_groupmembers() ;
  ::ServerRpc::group::groupMember* mutable_groupmembers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember >*
      mutable_groupmembers();
  private:
  const ::ServerRpc::group::groupMember& _internal_groupmembers(int index) const;
  ::ServerRpc::group::groupMember* _internal_add_groupmembers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupMember>& _internal_groupmembers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupMember>* _internal_mutable_groupmembers();
  public:
  const ::ServerRpc::group::groupMember& groupmembers(int index) const;
  ::ServerRpc::group::groupMember* add_groupmembers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember >&
      groupmembers() const;
  // @@protoc_insertion_point(class_scope:ServerRpc.group.getGroupMemberResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember > groupmembers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_group_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// groupMember

// .ServerRpc.user.user user = 1;
inline bool groupMember::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline const ::ServerRpc::user::user& groupMember::_internal_user() const {
  const ::ServerRpc::user::user* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerRpc::user::user&>(
      ::ServerRpc::user::_user_default_instance_);
}
inline const ::ServerRpc::user::user& groupMember::user() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.groupMember.user)
  return _internal_user();
}
inline void groupMember::unsafe_arena_set_allocated_user(
    ::ServerRpc::user::user* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerRpc.group.groupMember.user)
}
inline ::ServerRpc::user::user* groupMember::release_user() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::user::user* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerRpc::user::user* groupMember::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.groupMember.user)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::user::user* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::ServerRpc::user::user* groupMember::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerRpc::user::user>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::ServerRpc::user::user* groupMember::mutable_user() {
  ::ServerRpc::user::user* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.groupMember.user)
  return _msg;
}
inline void groupMember::set_allocated_user(::ServerRpc::user::user* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user));
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.groupMember.user)
}

// string groupID = 2;
inline void groupMember::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& groupMember::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.groupMember.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void groupMember::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.groupMember.groupID)
}
inline std::string* groupMember::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.groupMember.groupID)
  return _s;
}
inline const std::string& groupMember::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void groupMember::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* groupMember::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* groupMember::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.groupMember.groupID)
  return _impl_.groupid_.Release();
}
inline void groupMember::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.groupMember.groupID)
}

// .ServerRpc.group.groupMember.groupMemberRole role = 3;
inline void groupMember::clear_role() {
  _impl_.role_ = 0;
}
inline ::ServerRpc::group::groupMember_groupMemberRole groupMember::role() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.groupMember.role)
  return _internal_role();
}
inline void groupMember::set_role(::ServerRpc::group::groupMember_groupMemberRole value) {
   _internal_set_role(value);
  // @@protoc_insertion_point(field_set:ServerRpc.group.groupMember.role)
}
inline ::ServerRpc::group::groupMember_groupMemberRole groupMember::_internal_role() const {
  return static_cast<::ServerRpc::group::groupMember_groupMemberRole>(_impl_.role_);
}
inline void groupMember::_internal_set_role(::ServerRpc::group::groupMember_groupMemberRole value) {
  ;
  _impl_.role_ = value;
}

// -------------------------------------------------------------------

// groupInfo

// string groupName = 1;
inline void groupInfo::clear_groupname() {
  _impl_.groupname_.ClearToEmpty();
}
inline const std::string& groupInfo::groupname() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.groupInfo.groupName)
  return _internal_groupname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void groupInfo::set_groupname(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.groupInfo.groupName)
}
inline std::string* groupInfo::mutable_groupname() {
  std::string* _s = _internal_mutable_groupname();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.groupInfo.groupName)
  return _s;
}
inline const std::string& groupInfo::_internal_groupname() const {
  return _impl_.groupname_.Get();
}
inline void groupInfo::_internal_set_groupname(const std::string& value) {
  ;


  _impl_.groupname_.Set(value, GetArenaForAllocation());
}
inline std::string* groupInfo::_internal_mutable_groupname() {
  ;
  return _impl_.groupname_.Mutable( GetArenaForAllocation());
}
inline std::string* groupInfo::release_groupname() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.groupInfo.groupName)
  return _impl_.groupname_.Release();
}
inline void groupInfo::set_allocated_groupname(std::string* value) {
  _impl_.groupname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupname_.IsDefault()) {
          _impl_.groupname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.groupInfo.groupName)
}

// string groupDesc = 2;
inline void groupInfo::clear_groupdesc() {
  _impl_.groupdesc_.ClearToEmpty();
}
inline const std::string& groupInfo::groupdesc() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.groupInfo.groupDesc)
  return _internal_groupdesc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void groupInfo::set_groupdesc(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupdesc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.groupInfo.groupDesc)
}
inline std::string* groupInfo::mutable_groupdesc() {
  std::string* _s = _internal_mutable_groupdesc();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.groupInfo.groupDesc)
  return _s;
}
inline const std::string& groupInfo::_internal_groupdesc() const {
  return _impl_.groupdesc_.Get();
}
inline void groupInfo::_internal_set_groupdesc(const std::string& value) {
  ;


  _impl_.groupdesc_.Set(value, GetArenaForAllocation());
}
inline std::string* groupInfo::_internal_mutable_groupdesc() {
  ;
  return _impl_.groupdesc_.Mutable( GetArenaForAllocation());
}
inline std::string* groupInfo::release_groupdesc() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.groupInfo.groupDesc)
  return _impl_.groupdesc_.Release();
}
inline void groupInfo::set_allocated_groupdesc(std::string* value) {
  _impl_.groupdesc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupdesc_.IsDefault()) {
          _impl_.groupdesc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.groupInfo.groupDesc)
}

// string groupOwnerId = 3;
inline void groupInfo::clear_groupownerid() {
  _impl_.groupownerid_.ClearToEmpty();
}
inline const std::string& groupInfo::groupownerid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.groupInfo.groupOwnerId)
  return _internal_groupownerid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void groupInfo::set_groupownerid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupownerid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.groupInfo.groupOwnerId)
}
inline std::string* groupInfo::mutable_groupownerid() {
  std::string* _s = _internal_mutable_groupownerid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.groupInfo.groupOwnerId)
  return _s;
}
inline const std::string& groupInfo::_internal_groupownerid() const {
  return _impl_.groupownerid_.Get();
}
inline void groupInfo::_internal_set_groupownerid(const std::string& value) {
  ;


  _impl_.groupownerid_.Set(value, GetArenaForAllocation());
}
inline std::string* groupInfo::_internal_mutable_groupownerid() {
  ;
  return _impl_.groupownerid_.Mutable( GetArenaForAllocation());
}
inline std::string* groupInfo::release_groupownerid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.groupInfo.groupOwnerId)
  return _impl_.groupownerid_.Release();
}
inline void groupInfo::set_allocated_groupownerid(std::string* value) {
  _impl_.groupownerid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupownerid_.IsDefault()) {
          _impl_.groupownerid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.groupInfo.groupOwnerId)
}

// string groupId = 4;
inline void groupInfo::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& groupInfo::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.groupInfo.groupId)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void groupInfo::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.groupInfo.groupId)
}
inline std::string* groupInfo::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.groupInfo.groupId)
  return _s;
}
inline const std::string& groupInfo::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void groupInfo::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* groupInfo::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* groupInfo::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.groupInfo.groupId)
  return _impl_.groupid_.Release();
}
inline void groupInfo::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.groupInfo.groupId)
}

// repeated .ServerRpc.group.groupMember groupMembers = 5;
inline int groupInfo::_internal_groupmembers_size() const {
  return _impl_.groupmembers_.size();
}
inline int groupInfo::groupmembers_size() const {
  return _internal_groupmembers_size();
}
inline void groupInfo::clear_groupmembers() {
  _internal_mutable_groupmembers()->Clear();
}
inline ::ServerRpc::group::groupMember* groupInfo::mutable_groupmembers(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.groupInfo.groupMembers)
  return _internal_mutable_groupmembers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember >*
groupInfo::mutable_groupmembers() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.group.groupInfo.groupMembers)
  return _internal_mutable_groupmembers();
}
inline const ::ServerRpc::group::groupMember& groupInfo::_internal_groupmembers(int index) const {
  return _internal_groupmembers().Get(index);
}
inline const ::ServerRpc::group::groupMember& groupInfo::groupmembers(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.groupInfo.groupMembers)
  return _internal_groupmembers(index);
}
inline ::ServerRpc::group::groupMember* groupInfo::_internal_add_groupmembers() {
  return _internal_mutable_groupmembers()->Add();
}
inline ::ServerRpc::group::groupMember* groupInfo::add_groupmembers() {
  ::ServerRpc::group::groupMember* _add = _internal_add_groupmembers();
  // @@protoc_insertion_point(field_add:ServerRpc.group.groupInfo.groupMembers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember >&
groupInfo::groupmembers() const {
  // @@protoc_insertion_point(field_list:ServerRpc.group.groupInfo.groupMembers)
  return _internal_groupmembers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupMember>&
groupInfo::_internal_groupmembers() const {
  return _impl_.groupmembers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupMember>*
groupInfo::_internal_mutable_groupmembers() {
  return &_impl_.groupmembers_;
}

// -------------------------------------------------------------------

// createGroupReq

// string groupName = 1;
inline void createGroupReq::clear_groupname() {
  _impl_.groupname_.ClearToEmpty();
}
inline const std::string& createGroupReq::groupname() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.createGroupReq.groupName)
  return _internal_groupname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void createGroupReq::set_groupname(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.createGroupReq.groupName)
}
inline std::string* createGroupReq::mutable_groupname() {
  std::string* _s = _internal_mutable_groupname();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.createGroupReq.groupName)
  return _s;
}
inline const std::string& createGroupReq::_internal_groupname() const {
  return _impl_.groupname_.Get();
}
inline void createGroupReq::_internal_set_groupname(const std::string& value) {
  ;


  _impl_.groupname_.Set(value, GetArenaForAllocation());
}
inline std::string* createGroupReq::_internal_mutable_groupname() {
  ;
  return _impl_.groupname_.Mutable( GetArenaForAllocation());
}
inline std::string* createGroupReq::release_groupname() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.createGroupReq.groupName)
  return _impl_.groupname_.Release();
}
inline void createGroupReq::set_allocated_groupname(std::string* value) {
  _impl_.groupname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupname_.IsDefault()) {
          _impl_.groupname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.createGroupReq.groupName)
}

// string groupDesc = 2;
inline void createGroupReq::clear_groupdesc() {
  _impl_.groupdesc_.ClearToEmpty();
}
inline const std::string& createGroupReq::groupdesc() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.createGroupReq.groupDesc)
  return _internal_groupdesc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void createGroupReq::set_groupdesc(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupdesc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.createGroupReq.groupDesc)
}
inline std::string* createGroupReq::mutable_groupdesc() {
  std::string* _s = _internal_mutable_groupdesc();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.createGroupReq.groupDesc)
  return _s;
}
inline const std::string& createGroupReq::_internal_groupdesc() const {
  return _impl_.groupdesc_.Get();
}
inline void createGroupReq::_internal_set_groupdesc(const std::string& value) {
  ;


  _impl_.groupdesc_.Set(value, GetArenaForAllocation());
}
inline std::string* createGroupReq::_internal_mutable_groupdesc() {
  ;
  return _impl_.groupdesc_.Mutable( GetArenaForAllocation());
}
inline std::string* createGroupReq::release_groupdesc() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.createGroupReq.groupDesc)
  return _impl_.groupdesc_.Release();
}
inline void createGroupReq::set_allocated_groupdesc(std::string* value) {
  _impl_.groupdesc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupdesc_.IsDefault()) {
          _impl_.groupdesc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.createGroupReq.groupDesc)
}

// string groupOwnerId = 3;
inline void createGroupReq::clear_groupownerid() {
  _impl_.groupownerid_.ClearToEmpty();
}
inline const std::string& createGroupReq::groupownerid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.createGroupReq.groupOwnerId)
  return _internal_groupownerid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void createGroupReq::set_groupownerid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupownerid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.createGroupReq.groupOwnerId)
}
inline std::string* createGroupReq::mutable_groupownerid() {
  std::string* _s = _internal_mutable_groupownerid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.createGroupReq.groupOwnerId)
  return _s;
}
inline const std::string& createGroupReq::_internal_groupownerid() const {
  return _impl_.groupownerid_.Get();
}
inline void createGroupReq::_internal_set_groupownerid(const std::string& value) {
  ;


  _impl_.groupownerid_.Set(value, GetArenaForAllocation());
}
inline std::string* createGroupReq::_internal_mutable_groupownerid() {
  ;
  return _impl_.groupownerid_.Mutable( GetArenaForAllocation());
}
inline std::string* createGroupReq::release_groupownerid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.createGroupReq.groupOwnerId)
  return _impl_.groupownerid_.Release();
}
inline void createGroupReq::set_allocated_groupownerid(std::string* value) {
  _impl_.groupownerid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupownerid_.IsDefault()) {
          _impl_.groupownerid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.createGroupReq.groupOwnerId)
}

// string groupId = 4;
inline void createGroupReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& createGroupReq::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.createGroupReq.groupId)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void createGroupReq::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.createGroupReq.groupId)
}
inline std::string* createGroupReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.createGroupReq.groupId)
  return _s;
}
inline const std::string& createGroupReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void createGroupReq::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* createGroupReq::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* createGroupReq::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.createGroupReq.groupId)
  return _impl_.groupid_.Release();
}
inline void createGroupReq::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.createGroupReq.groupId)
}

// repeated string groupMemberIds = 5;
inline int createGroupReq::_internal_groupmemberids_size() const {
  return _impl_.groupmemberids_.size();
}
inline int createGroupReq::groupmemberids_size() const {
  return _internal_groupmemberids_size();
}
inline void createGroupReq::clear_groupmemberids() {
  _internal_mutable_groupmemberids()->Clear();
}
inline std::string* createGroupReq::add_groupmemberids() {
  std::string* _s = _internal_add_groupmemberids();
  // @@protoc_insertion_point(field_add_mutable:ServerRpc.group.createGroupReq.groupMemberIds)
  return _s;
}
inline const std::string& createGroupReq::groupmemberids(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.createGroupReq.groupMemberIds)
  return _internal_groupmemberids(index);
}
inline std::string* createGroupReq::mutable_groupmemberids(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.createGroupReq.groupMemberIds)
  return _internal_mutable_groupmemberids()->Mutable(index);
}
inline void createGroupReq::set_groupmemberids(int index, const std::string& value) {
  _internal_mutable_groupmemberids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline void createGroupReq::set_groupmemberids(int index, std::string&& value) {
  _internal_mutable_groupmemberids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline void createGroupReq::set_groupmemberids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_groupmemberids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline void createGroupReq::set_groupmemberids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_groupmemberids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline void createGroupReq::set_groupmemberids(int index, absl::string_view value) {
  _internal_mutable_groupmemberids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline void createGroupReq::add_groupmemberids(const std::string& value) {
  _internal_mutable_groupmemberids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline void createGroupReq::add_groupmemberids(std::string&& value) {
  _internal_mutable_groupmemberids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline void createGroupReq::add_groupmemberids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_groupmemberids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline void createGroupReq::add_groupmemberids(const char* value, std::size_t size) {
  _internal_mutable_groupmemberids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline void createGroupReq::add_groupmemberids(absl::string_view value) {
  _internal_mutable_groupmemberids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ServerRpc.group.createGroupReq.groupMemberIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
createGroupReq::groupmemberids() const {
  // @@protoc_insertion_point(field_list:ServerRpc.group.createGroupReq.groupMemberIds)
  return _internal_groupmemberids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* createGroupReq::mutable_groupmemberids() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.group.createGroupReq.groupMemberIds)
  return _internal_mutable_groupmemberids();
}
inline const std::string& createGroupReq::_internal_groupmemberids(int index) const {
  return _internal_groupmemberids().Get(index);
}
inline std::string* createGroupReq::_internal_add_groupmemberids() {
  return _internal_mutable_groupmemberids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
createGroupReq::_internal_groupmemberids() const {
  return _impl_.groupmemberids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
createGroupReq::_internal_mutable_groupmemberids() {
  return &_impl_.groupmemberids_;
}

// -------------------------------------------------------------------

// createGroupResp

// -------------------------------------------------------------------

// joinGroupReq

// string groupID = 1;
inline void joinGroupReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& joinGroupReq::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.joinGroupReq.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void joinGroupReq::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.joinGroupReq.groupID)
}
inline std::string* joinGroupReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.joinGroupReq.groupID)
  return _s;
}
inline const std::string& joinGroupReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void joinGroupReq::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* joinGroupReq::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* joinGroupReq::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.joinGroupReq.groupID)
  return _impl_.groupid_.Release();
}
inline void joinGroupReq::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.joinGroupReq.groupID)
}

// string userID = 2;
inline void joinGroupReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& joinGroupReq::userid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.joinGroupReq.userID)
  return _internal_userid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void joinGroupReq::set_userid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.userid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.joinGroupReq.userID)
}
inline std::string* joinGroupReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.joinGroupReq.userID)
  return _s;
}
inline const std::string& joinGroupReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void joinGroupReq::_internal_set_userid(const std::string& value) {
  ;


  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* joinGroupReq::_internal_mutable_userid() {
  ;
  return _impl_.userid_.Mutable( GetArenaForAllocation());
}
inline std::string* joinGroupReq::release_userid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.joinGroupReq.userID)
  return _impl_.userid_.Release();
}
inline void joinGroupReq::set_allocated_userid(std::string* value) {
  _impl_.userid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userid_.IsDefault()) {
          _impl_.userid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.joinGroupReq.userID)
}

// -------------------------------------------------------------------

// joinGroupResp

// -------------------------------------------------------------------

// getGroupInfoReq

// string groupID = 1;
inline void getGroupInfoReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& getGroupInfoReq::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.getGroupInfoReq.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getGroupInfoReq::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.getGroupInfoReq.groupID)
}
inline std::string* getGroupInfoReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.getGroupInfoReq.groupID)
  return _s;
}
inline const std::string& getGroupInfoReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void getGroupInfoReq::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* getGroupInfoReq::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* getGroupInfoReq::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.getGroupInfoReq.groupID)
  return _impl_.groupid_.Release();
}
inline void getGroupInfoReq::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.getGroupInfoReq.groupID)
}

// -------------------------------------------------------------------

// getGroupInfoResp

// .ServerRpc.group.groupInfo groupInfo = 2;
inline bool getGroupInfoResp::has_groupinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.groupinfo_ != nullptr);
  return value;
}
inline void getGroupInfoResp::clear_groupinfo() {
  if (_impl_.groupinfo_ != nullptr) _impl_.groupinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ServerRpc::group::groupInfo& getGroupInfoResp::_internal_groupinfo() const {
  const ::ServerRpc::group::groupInfo* p = _impl_.groupinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerRpc::group::groupInfo&>(
      ::ServerRpc::group::_groupInfo_default_instance_);
}
inline const ::ServerRpc::group::groupInfo& getGroupInfoResp::groupinfo() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.getGroupInfoResp.groupInfo)
  return _internal_groupinfo();
}
inline void getGroupInfoResp::unsafe_arena_set_allocated_groupinfo(
    ::ServerRpc::group::groupInfo* groupinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.groupinfo_);
  }
  _impl_.groupinfo_ = groupinfo;
  if (groupinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerRpc.group.getGroupInfoResp.groupInfo)
}
inline ::ServerRpc::group::groupInfo* getGroupInfoResp::release_groupinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::group::groupInfo* temp = _impl_.groupinfo_;
  _impl_.groupinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerRpc::group::groupInfo* getGroupInfoResp::unsafe_arena_release_groupinfo() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.getGroupInfoResp.groupInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerRpc::group::groupInfo* temp = _impl_.groupinfo_;
  _impl_.groupinfo_ = nullptr;
  return temp;
}
inline ::ServerRpc::group::groupInfo* getGroupInfoResp::_internal_mutable_groupinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.groupinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerRpc::group::groupInfo>(GetArenaForAllocation());
    _impl_.groupinfo_ = p;
  }
  return _impl_.groupinfo_;
}
inline ::ServerRpc::group::groupInfo* getGroupInfoResp::mutable_groupinfo() {
  ::ServerRpc::group::groupInfo* _msg = _internal_mutable_groupinfo();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.getGroupInfoResp.groupInfo)
  return _msg;
}
inline void getGroupInfoResp::set_allocated_groupinfo(::ServerRpc::group::groupInfo* groupinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.groupinfo_;
  }
  if (groupinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(groupinfo);
    if (message_arena != submessage_arena) {
      groupinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, groupinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.groupinfo_ = groupinfo;
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.getGroupInfoResp.groupInfo)
}

// -------------------------------------------------------------------

// getGroupListReq

// string userID = 1;
inline void getGroupListReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& getGroupListReq::userid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.getGroupListReq.userID)
  return _internal_userid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getGroupListReq::set_userid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.userid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.getGroupListReq.userID)
}
inline std::string* getGroupListReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.getGroupListReq.userID)
  return _s;
}
inline const std::string& getGroupListReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void getGroupListReq::_internal_set_userid(const std::string& value) {
  ;


  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* getGroupListReq::_internal_mutable_userid() {
  ;
  return _impl_.userid_.Mutable( GetArenaForAllocation());
}
inline std::string* getGroupListReq::release_userid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.getGroupListReq.userID)
  return _impl_.userid_.Release();
}
inline void getGroupListReq::set_allocated_userid(std::string* value) {
  _impl_.userid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userid_.IsDefault()) {
          _impl_.userid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.getGroupListReq.userID)
}

// -------------------------------------------------------------------

// getGroupListResp

// repeated .ServerRpc.group.groupInfo groupInfo = 2;
inline int getGroupListResp::_internal_groupinfo_size() const {
  return _impl_.groupinfo_.size();
}
inline int getGroupListResp::groupinfo_size() const {
  return _internal_groupinfo_size();
}
inline void getGroupListResp::clear_groupinfo() {
  _internal_mutable_groupinfo()->Clear();
}
inline ::ServerRpc::group::groupInfo* getGroupListResp::mutable_groupinfo(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.getGroupListResp.groupInfo)
  return _internal_mutable_groupinfo()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupInfo >*
getGroupListResp::mutable_groupinfo() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.group.getGroupListResp.groupInfo)
  return _internal_mutable_groupinfo();
}
inline const ::ServerRpc::group::groupInfo& getGroupListResp::_internal_groupinfo(int index) const {
  return _internal_groupinfo().Get(index);
}
inline const ::ServerRpc::group::groupInfo& getGroupListResp::groupinfo(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.getGroupListResp.groupInfo)
  return _internal_groupinfo(index);
}
inline ::ServerRpc::group::groupInfo* getGroupListResp::_internal_add_groupinfo() {
  return _internal_mutable_groupinfo()->Add();
}
inline ::ServerRpc::group::groupInfo* getGroupListResp::add_groupinfo() {
  ::ServerRpc::group::groupInfo* _add = _internal_add_groupinfo();
  // @@protoc_insertion_point(field_add:ServerRpc.group.getGroupListResp.groupInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupInfo >&
getGroupListResp::groupinfo() const {
  // @@protoc_insertion_point(field_list:ServerRpc.group.getGroupListResp.groupInfo)
  return _internal_groupinfo();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupInfo>&
getGroupListResp::_internal_groupinfo() const {
  return _impl_.groupinfo_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupInfo>*
getGroupListResp::_internal_mutable_groupinfo() {
  return &_impl_.groupinfo_;
}

// -------------------------------------------------------------------

// getGroupMemberReq

// string groupID = 1;
inline void getGroupMemberReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& getGroupMemberReq::groupid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.getGroupMemberReq.groupID)
  return _internal_groupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getGroupMemberReq::set_groupid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.groupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.group.getGroupMemberReq.groupID)
}
inline std::string* getGroupMemberReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.getGroupMemberReq.groupID)
  return _s;
}
inline const std::string& getGroupMemberReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void getGroupMemberReq::_internal_set_groupid(const std::string& value) {
  ;


  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* getGroupMemberReq::_internal_mutable_groupid() {
  ;
  return _impl_.groupid_.Mutable( GetArenaForAllocation());
}
inline std::string* getGroupMemberReq::release_groupid() {
  // @@protoc_insertion_point(field_release:ServerRpc.group.getGroupMemberReq.groupID)
  return _impl_.groupid_.Release();
}
inline void getGroupMemberReq::set_allocated_groupid(std::string* value) {
  _impl_.groupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupid_.IsDefault()) {
          _impl_.groupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.group.getGroupMemberReq.groupID)
}

// -------------------------------------------------------------------

// getGroupMemberResp

// repeated .ServerRpc.group.groupMember groupMembers = 2;
inline int getGroupMemberResp::_internal_groupmembers_size() const {
  return _impl_.groupmembers_.size();
}
inline int getGroupMemberResp::groupmembers_size() const {
  return _internal_groupmembers_size();
}
inline void getGroupMemberResp::clear_groupmembers() {
  _internal_mutable_groupmembers()->Clear();
}
inline ::ServerRpc::group::groupMember* getGroupMemberResp::mutable_groupmembers(int index) {
  // @@protoc_insertion_point(field_mutable:ServerRpc.group.getGroupMemberResp.groupMembers)
  return _internal_mutable_groupmembers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember >*
getGroupMemberResp::mutable_groupmembers() {
  // @@protoc_insertion_point(field_mutable_list:ServerRpc.group.getGroupMemberResp.groupMembers)
  return _internal_mutable_groupmembers();
}
inline const ::ServerRpc::group::groupMember& getGroupMemberResp::_internal_groupmembers(int index) const {
  return _internal_groupmembers().Get(index);
}
inline const ::ServerRpc::group::groupMember& getGroupMemberResp::groupmembers(int index) const {
  // @@protoc_insertion_point(field_get:ServerRpc.group.getGroupMemberResp.groupMembers)
  return _internal_groupmembers(index);
}
inline ::ServerRpc::group::groupMember* getGroupMemberResp::_internal_add_groupmembers() {
  return _internal_mutable_groupmembers()->Add();
}
inline ::ServerRpc::group::groupMember* getGroupMemberResp::add_groupmembers() {
  ::ServerRpc::group::groupMember* _add = _internal_add_groupmembers();
  // @@protoc_insertion_point(field_add:ServerRpc.group.getGroupMemberResp.groupMembers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerRpc::group::groupMember >&
getGroupMemberResp::groupmembers() const {
  // @@protoc_insertion_point(field_list:ServerRpc.group.getGroupMemberResp.groupMembers)
  return _internal_groupmembers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupMember>&
getGroupMemberResp::_internal_groupmembers() const {
  return _impl_.groupmembers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ServerRpc::group::groupMember>*
getGroupMemberResp::_internal_mutable_groupmembers() {
  return &_impl_.groupmembers_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace group
}  // namespace ServerRpc


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::ServerRpc::group::groupMember_groupMemberRole> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ServerRpc::group::groupMember_groupMemberRole>() {
  return ::ServerRpc::group::groupMember_groupMemberRole_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_group_2eproto_2epb_2eh
