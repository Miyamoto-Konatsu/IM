// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: auth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_auth_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_auth_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_auth_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_auth_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_auth_2eproto;
namespace ServerRpc {
namespace auth {
class forceLogoutReq;
struct forceLogoutReqDefaultTypeInternal;
extern forceLogoutReqDefaultTypeInternal _forceLogoutReq_default_instance_;
class forceLogoutResp;
struct forceLogoutRespDefaultTypeInternal;
extern forceLogoutRespDefaultTypeInternal _forceLogoutResp_default_instance_;
class parseTokenReq;
struct parseTokenReqDefaultTypeInternal;
extern parseTokenReqDefaultTypeInternal _parseTokenReq_default_instance_;
class parseTokenResp;
struct parseTokenRespDefaultTypeInternal;
extern parseTokenRespDefaultTypeInternal _parseTokenResp_default_instance_;
class userTokenReq;
struct userTokenReqDefaultTypeInternal;
extern userTokenReqDefaultTypeInternal _userTokenReq_default_instance_;
class userTokenResp;
struct userTokenRespDefaultTypeInternal;
extern userTokenRespDefaultTypeInternal _userTokenResp_default_instance_;
}  // namespace auth
}  // namespace ServerRpc
PROTOBUF_NAMESPACE_OPEN
template <>
::ServerRpc::auth::forceLogoutReq* Arena::CreateMaybeMessage<::ServerRpc::auth::forceLogoutReq>(Arena*);
template <>
::ServerRpc::auth::forceLogoutResp* Arena::CreateMaybeMessage<::ServerRpc::auth::forceLogoutResp>(Arena*);
template <>
::ServerRpc::auth::parseTokenReq* Arena::CreateMaybeMessage<::ServerRpc::auth::parseTokenReq>(Arena*);
template <>
::ServerRpc::auth::parseTokenResp* Arena::CreateMaybeMessage<::ServerRpc::auth::parseTokenResp>(Arena*);
template <>
::ServerRpc::auth::userTokenReq* Arena::CreateMaybeMessage<::ServerRpc::auth::userTokenReq>(Arena*);
template <>
::ServerRpc::auth::userTokenResp* Arena::CreateMaybeMessage<::ServerRpc::auth::userTokenResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace ServerRpc {
namespace auth {

// ===================================================================


// -------------------------------------------------------------------

class userTokenReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.auth.userTokenReq) */ {
 public:
  inline userTokenReq() : userTokenReq(nullptr) {}
  ~userTokenReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR userTokenReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  userTokenReq(const userTokenReq& from);
  userTokenReq(userTokenReq&& from) noexcept
    : userTokenReq() {
    *this = ::std::move(from);
  }

  inline userTokenReq& operator=(const userTokenReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline userTokenReq& operator=(userTokenReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const userTokenReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const userTokenReq* internal_default_instance() {
    return reinterpret_cast<const userTokenReq*>(
               &_userTokenReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(userTokenReq& a, userTokenReq& b) {
    a.Swap(&b);
  }
  inline void Swap(userTokenReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(userTokenReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  userTokenReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<userTokenReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const userTokenReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const userTokenReq& from) {
    userTokenReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(userTokenReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.auth.userTokenReq";
  }
  protected:
  explicit userTokenReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretFieldNumber = 1,
    kUserIDFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kPlatformIDFieldNumber = 2,
  };
  // string secret = 1;
  void clear_secret() ;
  const std::string& secret() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* ptr);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // string userID = 3;
  void clear_userid() ;
  const std::string& userid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userid(Arg_&& arg, Args_... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* ptr);

  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(
      const std::string& value);
  std::string* _internal_mutable_userid();

  public:
  // string password = 4;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // int32 platformID = 2;
  void clear_platformid() ;
  ::int32_t platformid() const;
  void set_platformid(::int32_t value);

  private:
  ::int32_t _internal_platformid() const;
  void _internal_set_platformid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.auth.userTokenReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::int32_t platformid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class userTokenResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.auth.userTokenResp) */ {
 public:
  inline userTokenResp() : userTokenResp(nullptr) {}
  ~userTokenResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR userTokenResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  userTokenResp(const userTokenResp& from);
  userTokenResp(userTokenResp&& from) noexcept
    : userTokenResp() {
    *this = ::std::move(from);
  }

  inline userTokenResp& operator=(const userTokenResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline userTokenResp& operator=(userTokenResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const userTokenResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const userTokenResp* internal_default_instance() {
    return reinterpret_cast<const userTokenResp*>(
               &_userTokenResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(userTokenResp& a, userTokenResp& b) {
    a.Swap(&b);
  }
  inline void Swap(userTokenResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(userTokenResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  userTokenResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<userTokenResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const userTokenResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const userTokenResp& from) {
    userTokenResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(userTokenResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.auth.userTokenResp";
  }
  protected:
  explicit userTokenResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kExpireTimeSecondsFieldNumber = 3,
  };
  // string token = 2;
  void clear_token() ;
  const std::string& token() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // int64 expireTimeSeconds = 3;
  void clear_expiretimeseconds() ;
  ::int64_t expiretimeseconds() const;
  void set_expiretimeseconds(::int64_t value);

  private:
  ::int64_t _internal_expiretimeseconds() const;
  void _internal_set_expiretimeseconds(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.auth.userTokenResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::int64_t expiretimeseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class forceLogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.auth.forceLogoutReq) */ {
 public:
  inline forceLogoutReq() : forceLogoutReq(nullptr) {}
  ~forceLogoutReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR forceLogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  forceLogoutReq(const forceLogoutReq& from);
  forceLogoutReq(forceLogoutReq&& from) noexcept
    : forceLogoutReq() {
    *this = ::std::move(from);
  }

  inline forceLogoutReq& operator=(const forceLogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline forceLogoutReq& operator=(forceLogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const forceLogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const forceLogoutReq* internal_default_instance() {
    return reinterpret_cast<const forceLogoutReq*>(
               &_forceLogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(forceLogoutReq& a, forceLogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(forceLogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(forceLogoutReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  forceLogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<forceLogoutReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const forceLogoutReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const forceLogoutReq& from) {
    forceLogoutReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(forceLogoutReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.auth.forceLogoutReq";
  }
  protected:
  explicit forceLogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 2,
    kPlatformIDFieldNumber = 1,
  };
  // string userID = 2;
  void clear_userid() ;
  const std::string& userid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userid(Arg_&& arg, Args_... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* ptr);

  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(
      const std::string& value);
  std::string* _internal_mutable_userid();

  public:
  // int32 platformID = 1;
  void clear_platformid() ;
  ::int32_t platformid() const;
  void set_platformid(::int32_t value);

  private:
  ::int32_t _internal_platformid() const;
  void _internal_set_platformid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.auth.forceLogoutReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::int32_t platformid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class forceLogoutResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerRpc.auth.forceLogoutResp) */ {
 public:
  inline forceLogoutResp() : forceLogoutResp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR forceLogoutResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  forceLogoutResp(const forceLogoutResp& from);
  forceLogoutResp(forceLogoutResp&& from) noexcept
    : forceLogoutResp() {
    *this = ::std::move(from);
  }

  inline forceLogoutResp& operator=(const forceLogoutResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline forceLogoutResp& operator=(forceLogoutResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const forceLogoutResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const forceLogoutResp* internal_default_instance() {
    return reinterpret_cast<const forceLogoutResp*>(
               &_forceLogoutResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(forceLogoutResp& a, forceLogoutResp& b) {
    a.Swap(&b);
  }
  inline void Swap(forceLogoutResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(forceLogoutResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  forceLogoutResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<forceLogoutResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const forceLogoutResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const forceLogoutResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.auth.forceLogoutResp";
  }
  protected:
  explicit forceLogoutResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerRpc.auth.forceLogoutResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class parseTokenReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.auth.parseTokenReq) */ {
 public:
  inline parseTokenReq() : parseTokenReq(nullptr) {}
  ~parseTokenReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR parseTokenReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  parseTokenReq(const parseTokenReq& from);
  parseTokenReq(parseTokenReq&& from) noexcept
    : parseTokenReq() {
    *this = ::std::move(from);
  }

  inline parseTokenReq& operator=(const parseTokenReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline parseTokenReq& operator=(parseTokenReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const parseTokenReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const parseTokenReq* internal_default_instance() {
    return reinterpret_cast<const parseTokenReq*>(
               &_parseTokenReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(parseTokenReq& a, parseTokenReq& b) {
    a.Swap(&b);
  }
  inline void Swap(parseTokenReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(parseTokenReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  parseTokenReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<parseTokenReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const parseTokenReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const parseTokenReq& from) {
    parseTokenReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(parseTokenReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.auth.parseTokenReq";
  }
  protected:
  explicit parseTokenReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.auth.parseTokenReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class parseTokenResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerRpc.auth.parseTokenResp) */ {
 public:
  inline parseTokenResp() : parseTokenResp(nullptr) {}
  ~parseTokenResp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR parseTokenResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  parseTokenResp(const parseTokenResp& from);
  parseTokenResp(parseTokenResp&& from) noexcept
    : parseTokenResp() {
    *this = ::std::move(from);
  }

  inline parseTokenResp& operator=(const parseTokenResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline parseTokenResp& operator=(parseTokenResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const parseTokenResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const parseTokenResp* internal_default_instance() {
    return reinterpret_cast<const parseTokenResp*>(
               &_parseTokenResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(parseTokenResp& a, parseTokenResp& b) {
    a.Swap(&b);
  }
  inline void Swap(parseTokenResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(parseTokenResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  parseTokenResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<parseTokenResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const parseTokenResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const parseTokenResp& from) {
    parseTokenResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(parseTokenResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ServerRpc.auth.parseTokenResp";
  }
  protected:
  explicit parseTokenResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kPlatformFieldNumber = 2,
    kExpireTimeSecondsFieldNumber = 4,
  };
  // string userID = 1;
  void clear_userid() ;
  const std::string& userid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userid(Arg_&& arg, Args_... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* ptr);

  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(
      const std::string& value);
  std::string* _internal_mutable_userid();

  public:
  // string platform = 2;
  void clear_platform() ;
  const std::string& platform() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform(Arg_&& arg, Args_... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* ptr);

  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(
      const std::string& value);
  std::string* _internal_mutable_platform();

  public:
  // int64 expireTimeSeconds = 4;
  void clear_expiretimeseconds() ;
  ::int64_t expiretimeseconds() const;
  void set_expiretimeseconds(::int64_t value);

  private:
  ::int64_t _internal_expiretimeseconds() const;
  void _internal_set_expiretimeseconds(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ServerRpc.auth.parseTokenResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
    ::int64_t expiretimeseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// userTokenReq

// string secret = 1;
inline void userTokenReq::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& userTokenReq::secret() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.userTokenReq.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void userTokenReq::set_secret(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.auth.userTokenReq.secret)
}
inline std::string* userTokenReq::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:ServerRpc.auth.userTokenReq.secret)
  return _s;
}
inline const std::string& userTokenReq::_internal_secret() const {
  return _impl_.secret_.Get();
}
inline void userTokenReq::_internal_set_secret(const std::string& value) {
  ;


  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* userTokenReq::_internal_mutable_secret() {
  ;
  return _impl_.secret_.Mutable( GetArenaForAllocation());
}
inline std::string* userTokenReq::release_secret() {
  // @@protoc_insertion_point(field_release:ServerRpc.auth.userTokenReq.secret)
  return _impl_.secret_.Release();
}
inline void userTokenReq::set_allocated_secret(std::string* value) {
  _impl_.secret_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.auth.userTokenReq.secret)
}

// int32 platformID = 2;
inline void userTokenReq::clear_platformid() {
  _impl_.platformid_ = 0;
}
inline ::int32_t userTokenReq::platformid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.userTokenReq.platformID)
  return _internal_platformid();
}
inline void userTokenReq::set_platformid(::int32_t value) {
  _internal_set_platformid(value);
  // @@protoc_insertion_point(field_set:ServerRpc.auth.userTokenReq.platformID)
}
inline ::int32_t userTokenReq::_internal_platformid() const {
  return _impl_.platformid_;
}
inline void userTokenReq::_internal_set_platformid(::int32_t value) {
  ;
  _impl_.platformid_ = value;
}

// string userID = 3;
inline void userTokenReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& userTokenReq::userid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.userTokenReq.userID)
  return _internal_userid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void userTokenReq::set_userid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.userid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.auth.userTokenReq.userID)
}
inline std::string* userTokenReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.auth.userTokenReq.userID)
  return _s;
}
inline const std::string& userTokenReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void userTokenReq::_internal_set_userid(const std::string& value) {
  ;


  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* userTokenReq::_internal_mutable_userid() {
  ;
  return _impl_.userid_.Mutable( GetArenaForAllocation());
}
inline std::string* userTokenReq::release_userid() {
  // @@protoc_insertion_point(field_release:ServerRpc.auth.userTokenReq.userID)
  return _impl_.userid_.Release();
}
inline void userTokenReq::set_allocated_userid(std::string* value) {
  _impl_.userid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userid_.IsDefault()) {
          _impl_.userid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.auth.userTokenReq.userID)
}

// string password = 4;
inline void userTokenReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& userTokenReq::password() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.userTokenReq.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void userTokenReq::set_password(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.auth.userTokenReq.password)
}
inline std::string* userTokenReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ServerRpc.auth.userTokenReq.password)
  return _s;
}
inline const std::string& userTokenReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void userTokenReq::_internal_set_password(const std::string& value) {
  ;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* userTokenReq::_internal_mutable_password() {
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* userTokenReq::release_password() {
  // @@protoc_insertion_point(field_release:ServerRpc.auth.userTokenReq.password)
  return _impl_.password_.Release();
}
inline void userTokenReq::set_allocated_password(std::string* value) {
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.auth.userTokenReq.password)
}

// -------------------------------------------------------------------

// userTokenResp

// string token = 2;
inline void userTokenResp::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& userTokenResp::token() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.userTokenResp.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void userTokenResp::set_token(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.auth.userTokenResp.token)
}
inline std::string* userTokenResp::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:ServerRpc.auth.userTokenResp.token)
  return _s;
}
inline const std::string& userTokenResp::_internal_token() const {
  return _impl_.token_.Get();
}
inline void userTokenResp::_internal_set_token(const std::string& value) {
  ;


  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* userTokenResp::_internal_mutable_token() {
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* userTokenResp::release_token() {
  // @@protoc_insertion_point(field_release:ServerRpc.auth.userTokenResp.token)
  return _impl_.token_.Release();
}
inline void userTokenResp::set_allocated_token(std::string* value) {
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.auth.userTokenResp.token)
}

// int64 expireTimeSeconds = 3;
inline void userTokenResp::clear_expiretimeseconds() {
  _impl_.expiretimeseconds_ = ::int64_t{0};
}
inline ::int64_t userTokenResp::expiretimeseconds() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.userTokenResp.expireTimeSeconds)
  return _internal_expiretimeseconds();
}
inline void userTokenResp::set_expiretimeseconds(::int64_t value) {
  _internal_set_expiretimeseconds(value);
  // @@protoc_insertion_point(field_set:ServerRpc.auth.userTokenResp.expireTimeSeconds)
}
inline ::int64_t userTokenResp::_internal_expiretimeseconds() const {
  return _impl_.expiretimeseconds_;
}
inline void userTokenResp::_internal_set_expiretimeseconds(::int64_t value) {
  ;
  _impl_.expiretimeseconds_ = value;
}

// -------------------------------------------------------------------

// forceLogoutReq

// int32 platformID = 1;
inline void forceLogoutReq::clear_platformid() {
  _impl_.platformid_ = 0;
}
inline ::int32_t forceLogoutReq::platformid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.forceLogoutReq.platformID)
  return _internal_platformid();
}
inline void forceLogoutReq::set_platformid(::int32_t value) {
  _internal_set_platformid(value);
  // @@protoc_insertion_point(field_set:ServerRpc.auth.forceLogoutReq.platformID)
}
inline ::int32_t forceLogoutReq::_internal_platformid() const {
  return _impl_.platformid_;
}
inline void forceLogoutReq::_internal_set_platformid(::int32_t value) {
  ;
  _impl_.platformid_ = value;
}

// string userID = 2;
inline void forceLogoutReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& forceLogoutReq::userid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.forceLogoutReq.userID)
  return _internal_userid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void forceLogoutReq::set_userid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.userid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.auth.forceLogoutReq.userID)
}
inline std::string* forceLogoutReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.auth.forceLogoutReq.userID)
  return _s;
}
inline const std::string& forceLogoutReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void forceLogoutReq::_internal_set_userid(const std::string& value) {
  ;


  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* forceLogoutReq::_internal_mutable_userid() {
  ;
  return _impl_.userid_.Mutable( GetArenaForAllocation());
}
inline std::string* forceLogoutReq::release_userid() {
  // @@protoc_insertion_point(field_release:ServerRpc.auth.forceLogoutReq.userID)
  return _impl_.userid_.Release();
}
inline void forceLogoutReq::set_allocated_userid(std::string* value) {
  _impl_.userid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userid_.IsDefault()) {
          _impl_.userid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.auth.forceLogoutReq.userID)
}

// -------------------------------------------------------------------

// forceLogoutResp

// -------------------------------------------------------------------

// parseTokenReq

// string token = 1;
inline void parseTokenReq::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& parseTokenReq::token() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.parseTokenReq.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void parseTokenReq::set_token(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.auth.parseTokenReq.token)
}
inline std::string* parseTokenReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:ServerRpc.auth.parseTokenReq.token)
  return _s;
}
inline const std::string& parseTokenReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void parseTokenReq::_internal_set_token(const std::string& value) {
  ;


  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* parseTokenReq::_internal_mutable_token() {
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* parseTokenReq::release_token() {
  // @@protoc_insertion_point(field_release:ServerRpc.auth.parseTokenReq.token)
  return _impl_.token_.Release();
}
inline void parseTokenReq::set_allocated_token(std::string* value) {
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.auth.parseTokenReq.token)
}

// -------------------------------------------------------------------

// parseTokenResp

// string userID = 1;
inline void parseTokenResp::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& parseTokenResp::userid() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.parseTokenResp.userID)
  return _internal_userid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void parseTokenResp::set_userid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.userid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.auth.parseTokenResp.userID)
}
inline std::string* parseTokenResp::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerRpc.auth.parseTokenResp.userID)
  return _s;
}
inline const std::string& parseTokenResp::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void parseTokenResp::_internal_set_userid(const std::string& value) {
  ;


  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* parseTokenResp::_internal_mutable_userid() {
  ;
  return _impl_.userid_.Mutable( GetArenaForAllocation());
}
inline std::string* parseTokenResp::release_userid() {
  // @@protoc_insertion_point(field_release:ServerRpc.auth.parseTokenResp.userID)
  return _impl_.userid_.Release();
}
inline void parseTokenResp::set_allocated_userid(std::string* value) {
  _impl_.userid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userid_.IsDefault()) {
          _impl_.userid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.auth.parseTokenResp.userID)
}

// string platform = 2;
inline void parseTokenResp::clear_platform() {
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& parseTokenResp::platform() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.parseTokenResp.platform)
  return _internal_platform();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void parseTokenResp::set_platform(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.platform_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerRpc.auth.parseTokenResp.platform)
}
inline std::string* parseTokenResp::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:ServerRpc.auth.parseTokenResp.platform)
  return _s;
}
inline const std::string& parseTokenResp::_internal_platform() const {
  return _impl_.platform_.Get();
}
inline void parseTokenResp::_internal_set_platform(const std::string& value) {
  ;


  _impl_.platform_.Set(value, GetArenaForAllocation());
}
inline std::string* parseTokenResp::_internal_mutable_platform() {
  ;
  return _impl_.platform_.Mutable( GetArenaForAllocation());
}
inline std::string* parseTokenResp::release_platform() {
  // @@protoc_insertion_point(field_release:ServerRpc.auth.parseTokenResp.platform)
  return _impl_.platform_.Release();
}
inline void parseTokenResp::set_allocated_platform(std::string* value) {
  _impl_.platform_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.platform_.IsDefault()) {
          _impl_.platform_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerRpc.auth.parseTokenResp.platform)
}

// int64 expireTimeSeconds = 4;
inline void parseTokenResp::clear_expiretimeseconds() {
  _impl_.expiretimeseconds_ = ::int64_t{0};
}
inline ::int64_t parseTokenResp::expiretimeseconds() const {
  // @@protoc_insertion_point(field_get:ServerRpc.auth.parseTokenResp.expireTimeSeconds)
  return _internal_expiretimeseconds();
}
inline void parseTokenResp::set_expiretimeseconds(::int64_t value) {
  _internal_set_expiretimeseconds(value);
  // @@protoc_insertion_point(field_set:ServerRpc.auth.parseTokenResp.expireTimeSeconds)
}
inline ::int64_t parseTokenResp::_internal_expiretimeseconds() const {
  return _impl_.expiretimeseconds_;
}
inline void parseTokenResp::_internal_set_expiretimeseconds(::int64_t value) {
  ;
  _impl_.expiretimeseconds_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace auth
}  // namespace ServerRpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_auth_2eproto_2epb_2eh
